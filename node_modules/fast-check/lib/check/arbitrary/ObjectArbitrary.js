"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unicodeJson = exports.json = exports.unicodeJsonObject = exports.jsonObject = exports.object = exports.anything = exports.boxArbitrary = void 0;
const stringify_1 = require("../../utils/stringify");
const array_1 = require("../../arbitrary/array");
const boolean_1 = require("../../arbitrary/boolean");
const constant_1 = require("../../arbitrary/constant");
const dictionary_1 = require("../../arbitrary/dictionary");
const FloatingPointArbitrary_1 = require("./FloatingPointArbitrary");
const frequency_1 = require("../../arbitrary/frequency");
const maxSafeInteger_1 = require("../../arbitrary/maxSafeInteger");
const memo_1 = require("../../arbitrary/memo");
const oneof_1 = require("../../arbitrary/oneof");
const set_1 = require("../../arbitrary/set");
const string_1 = require("../../arbitrary/string");
const unicodeString_1 = require("../../arbitrary/unicodeString");
const tuple_1 = require("../../arbitrary/tuple");
const bigInt_1 = require("../../arbitrary/bigInt");
const date_1 = require("../../arbitrary/date");
const float32Array_1 = require("../../arbitrary/float32Array");
const float64Array_1 = require("../../arbitrary/float64Array");
const int16Array_1 = require("../../arbitrary/int16Array");
const int32Array_1 = require("../../arbitrary/int32Array");
const int8Array_1 = require("../../arbitrary/int8Array");
const uint16Array_1 = require("../../arbitrary/uint16Array");
const uint32Array_1 = require("../../arbitrary/uint32Array");
const uint8Array_1 = require("../../arbitrary/uint8Array");
const uint8ClampedArray_1 = require("../../arbitrary/uint8ClampedArray");
const SparseArrayArbitrary_1 = require("./SparseArrayArbitrary");
const KeyValuePairsToObject_1 = require("../../arbitrary/_internals/mappers/KeyValuePairsToObject");
function boxArbitrary(arb) {
    return arb.map((v) => {
        switch (typeof v) {
            case 'boolean':
                return new Boolean(v);
            case 'number':
                return new Number(v);
            case 'string':
                return new String(v);
            default:
                return v;
        }
    });
}
exports.boxArbitrary = boxArbitrary;
class QualifiedObjectConstraints {
    constructor(key, values, maxDepth, maxKeys, withSet, withMap, withObjectString, withNullPrototype, withBigInt, withDate, withTypedArray, withSparseArray) {
        this.key = key;
        this.values = values;
        this.maxDepth = maxDepth;
        this.maxKeys = maxKeys;
        this.withSet = withSet;
        this.withMap = withMap;
        this.withObjectString = withObjectString;
        this.withNullPrototype = withNullPrototype;
        this.withBigInt = withBigInt;
        this.withDate = withDate;
        this.withTypedArray = withTypedArray;
        this.withSparseArray = withSparseArray;
    }
    static defaultValues() {
        return [
            boolean_1.boolean(),
            maxSafeInteger_1.maxSafeInteger(),
            FloatingPointArbitrary_1.double({ next: true }),
            string_1.string(),
            oneof_1.oneof(string_1.string(), constant_1.constant(null), constant_1.constant(undefined)),
        ];
    }
    static boxArbitraries(arbs) {
        return arbs.map((arb) => boxArbitrary(arb));
    }
    static boxArbitrariesIfNeeded(arbs, boxEnabled) {
        return boxEnabled ? QualifiedObjectConstraints.boxArbitraries(arbs).concat(arbs) : arbs;
    }
    static from(settings = {}) {
        function orDefault(optionalValue, defaultValue) {
            return optionalValue !== undefined ? optionalValue : defaultValue;
        }
        return new QualifiedObjectConstraints(orDefault(settings.key, string_1.string()), QualifiedObjectConstraints.boxArbitrariesIfNeeded(orDefault(settings.values, QualifiedObjectConstraints.defaultValues()), orDefault(settings.withBoxedValues, false)), orDefault(settings.maxDepth, 2), orDefault(settings.maxKeys, 5), orDefault(settings.withSet, false), orDefault(settings.withMap, false), orDefault(settings.withObjectString, false), orDefault(settings.withNullPrototype, false), orDefault(settings.withBigInt, false), orDefault(settings.withDate, false), orDefault(settings.withTypedArray, false), orDefault(settings.withSparseArray, false));
    }
}
const anythingInternal = (constraints) => {
    const arbKeys = constraints.withObjectString
        ? memo_1.memo((n) => frequency_1.frequency({ arbitrary: constraints.key, weight: 10 }, { arbitrary: anythingArb(n).map((o) => stringify_1.stringify(o)), weight: 1 }))
        : memo_1.memo(() => constraints.key);
    const arbitrariesForBase = constraints.values;
    const maxDepth = constraints.maxDepth;
    const maxKeys = constraints.maxKeys;
    const entriesOf = (keyArb, valueArb) => set_1.set(tuple_1.tuple(keyArb, valueArb), { maxLength: maxKeys, compare: (t1, t2) => t1[0] === t2[0] });
    const mapOf = (ka, va) => entriesOf(ka, va).map((v) => new Map(v));
    const dictOf = (ka, va) => entriesOf(ka, va).map((v) => KeyValuePairsToObject_1.keyValuePairsToObjectMapper(v));
    const baseArb = oneof_1.oneof(...arbitrariesForBase);
    const arrayBaseArb = oneof_1.oneof(...arbitrariesForBase.map((arb) => array_1.array(arb, { maxLength: maxKeys })));
    const objectBaseArb = (n) => oneof_1.oneof(...arbitrariesForBase.map((arb) => dictOf(arbKeys(n), arb)));
    const setBaseArb = () => oneof_1.oneof(...arbitrariesForBase.map((arb) => set_1.set(arb, { maxLength: maxKeys }).map((v) => new Set(v))));
    const mapBaseArb = (n) => oneof_1.oneof(...arbitrariesForBase.map((arb) => mapOf(arbKeys(n), arb)));
    const arrayArb = memo_1.memo((n) => oneof_1.oneof(arrayBaseArb, array_1.array(anythingArb(n), { maxLength: maxKeys })));
    const setArb = memo_1.memo((n) => oneof_1.oneof(setBaseArb(), set_1.set(anythingArb(n), { maxLength: maxKeys }).map((v) => new Set(v))));
    const mapArb = memo_1.memo((n) => oneof_1.oneof(mapBaseArb(n), oneof_1.oneof(mapOf(arbKeys(n), anythingArb(n)), mapOf(anythingArb(n), anythingArb(n)))));
    const objectArb = memo_1.memo((n) => oneof_1.oneof(objectBaseArb(n), dictOf(arbKeys(n), anythingArb(n))));
    const anythingArb = memo_1.memo((n) => {
        if (n <= 0)
            return oneof_1.oneof(baseArb);
        return oneof_1.oneof(baseArb, arrayArb(), objectArb(), ...(constraints.withMap ? [mapArb()] : []), ...(constraints.withSet ? [setArb()] : []), ...(constraints.withObjectString ? [anythingArb().map((o) => stringify_1.stringify(o))] : []), ...(constraints.withNullPrototype ? [objectArb().map((o) => Object.assign(Object.create(null), o))] : []), ...(constraints.withBigInt ? [bigInt_1.bigInt()] : []), ...(constraints.withDate ? [date_1.date()] : []), ...(constraints.withTypedArray
            ? [
                oneof_1.oneof(int8Array_1.int8Array(), uint8Array_1.uint8Array(), uint8ClampedArray_1.uint8ClampedArray(), int16Array_1.int16Array(), uint16Array_1.uint16Array(), int32Array_1.int32Array(), uint32Array_1.uint32Array(), float32Array_1.float32Array(), float64Array_1.float64Array()),
            ]
            : []), ...(constraints.withSparseArray ? [SparseArrayArbitrary_1.sparseArray(anythingArb())] : []));
    });
    return anythingArb(maxDepth);
};
const objectInternal = (constraints) => {
    return dictionary_1.dictionary(constraints.key, anythingInternal(constraints));
};
function anything(constraints) {
    return anythingInternal(QualifiedObjectConstraints.from(constraints));
}
exports.anything = anything;
function object(constraints) {
    return objectInternal(QualifiedObjectConstraints.from(constraints));
}
exports.object = object;
function jsonSettings(stringArbitrary, constraints) {
    const key = stringArbitrary;
    const values = [
        boolean_1.boolean(),
        maxSafeInteger_1.maxSafeInteger(),
        FloatingPointArbitrary_1.double({ next: true, noDefaultInfinity: true, noNaN: true }),
        stringArbitrary,
        constant_1.constant(null),
    ];
    return constraints != null
        ? typeof constraints === 'number'
            ? { key, values, maxDepth: constraints }
            : { key, values, maxDepth: constraints.maxDepth }
        : { key, values };
}
function jsonObject(constraints) {
    return anything(jsonSettings(string_1.string(), constraints));
}
exports.jsonObject = jsonObject;
function unicodeJsonObject(constraints) {
    return anything(jsonSettings(unicodeString_1.unicodeString(), constraints));
}
exports.unicodeJsonObject = unicodeJsonObject;
function json(constraints) {
    const arb = constraints != null ? jsonObject(constraints) : jsonObject();
    return arb.map(JSON.stringify);
}
exports.json = json;
function unicodeJson(constraints) {
    const arb = constraints != null ? unicodeJsonObject(constraints) : unicodeJsonObject();
    return arb.map(JSON.stringify);
}
exports.unicodeJson = unicodeJson;
