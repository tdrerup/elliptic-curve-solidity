import { Stream } from '../../stream/Stream.js';
import { bigUintN } from '../bigUintN.js';
import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';
import { convertToNext } from '../../check/arbitrary/definition/Converters.js';
import { NextValue } from '../../check/arbitrary/definition/NextValue.js';
import { makeLazy } from '../../stream/LazyIterableIterator.js';
export function countToggledBits(n) {
    let count = 0;
    while (n > BigInt(0)) {
        if (n & BigInt(1))
            ++count;
        n >>= BigInt(1);
    }
    return count;
}
export function computeNextFlags(flags, nextSize) {
    const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);
    const preservedFlags = flags & allowedMask;
    let numMissingFlags = countToggledBits(flags - preservedFlags);
    let nFlags = preservedFlags;
    for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {
        if (!(nFlags & mask)) {
            nFlags |= mask;
            --numMissingFlags;
        }
    }
    return nFlags;
}
export class MixedCaseArbitrary extends NextArbitrary {
    constructor(stringArb, toggleCase) {
        super();
        this.stringArb = stringArb;
        this.toggleCase = toggleCase;
    }
    computeTogglePositions(chars) {
        const positions = [];
        for (let idx = 0; idx !== chars.length; ++idx) {
            if (this.toggleCase(chars[idx]) !== chars[idx])
                positions.push(idx);
        }
        return positions;
    }
    applyFlagsOnChars(chars, flags, togglePositions) {
        for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {
            if (flags & mask)
                chars[togglePositions[idx]] = this.toggleCase(chars[togglePositions[idx]]);
        }
        return chars;
    }
    buildContextFor(rawStringNextValue, flagsNextValue) {
        return {
            rawString: rawStringNextValue.value,
            rawStringContext: rawStringNextValue.context,
            flags: flagsNextValue.value,
            flagsContext: flagsNextValue.context,
        };
    }
    generate(mrng, biasFactor) {
        const rawStringNextValue = this.stringArb.generate(mrng, biasFactor);
        const chars = [...rawStringNextValue.value];
        const togglePositions = this.computeTogglePositions(chars);
        const flagsArb = convertToNext(bigUintN(togglePositions.length));
        const flagsNextValue = flagsArb.generate(mrng, undefined);
        this.applyFlagsOnChars(chars, flagsNextValue.value, togglePositions);
        return new NextValue(chars.join(''), this.buildContextFor(rawStringNextValue, flagsNextValue));
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, context) {
        if (context === undefined) {
            return Stream.nil();
        }
        const contextSafe = context;
        const rawString = contextSafe.rawString;
        const flags = contextSafe.flags;
        return this.stringArb
            .shrink(rawString, contextSafe.rawStringContext)
            .map((nRawStringNextValue) => {
            const nChars = [...nRawStringNextValue.value];
            const nTogglePositions = this.computeTogglePositions(nChars);
            const nFlags = computeNextFlags(flags, nTogglePositions.length);
            this.applyFlagsOnChars(nChars, nFlags, nTogglePositions);
            return new NextValue(nChars.join(''), this.buildContextFor(nRawStringNextValue, new NextValue(nFlags, undefined)));
        })
            .join(makeLazy(() => {
            const chars = [...rawString];
            const togglePositions = this.computeTogglePositions(chars);
            return convertToNext(bigUintN(togglePositions.length))
                .shrink(flags, contextSafe.flagsContext)
                .map((nFlagsNextValue) => {
                const nChars = chars.slice();
                this.applyFlagsOnChars(nChars, nFlagsNextValue.value, togglePositions);
                return new NextValue(nChars.join(''), this.buildContextFor(new NextValue(rawString, contextSafe.rawStringContext), nFlagsNextValue));
            });
        }));
    }
}
