"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Abi = exports.ConstructorFunction = exports.FallbackFunction = exports.ReceiveFunction = exports.NormalFunction = exports.Event = exports.EventParameter = exports.Parameter = exports.TypeRecord = exports.FunctionName = exports.EventName = exports.ParameterName = exports.Type = exports.Primitive = exports.Primitives = exports.Numerics = void 0;
const fc = __importStar(require("fast-check"));
const faker_1 = __importDefault(require("faker"));
const change_case_1 = require("change-case");
var Numerics;
(function (Numerics) {
    // 0 < n <= 32
    Numerics.Bytes = () => fc.nat(31).map((k) => 32 - k);
    // o < n <= 256
    Numerics.Bits = () => Numerics.Bytes().map((k) => 8 * k);
    // 0 < n < 80
    Numerics.DecimalPlaces = () => fc.nat(79).map((k) => k + 1);
    Numerics.Precision = () => fc.tuple(Numerics.Bits(), Numerics.DecimalPlaces());
})(Numerics = exports.Numerics || (exports.Numerics = {}));
var Primitives;
(function (Primitives) {
    Primitives.Uint = () => Numerics.Bits().map((m) => `uint${m}`);
    Primitives.Int = () => Numerics.Bits().map((m) => `int${m}`);
    Primitives.Address = () => fc.constant("address");
    Primitives.Bool = () => fc.constant("bool");
    Primitives.Fixed = () => Numerics.Precision().map(([m, n]) => `fixed${m}x${n}`);
    Primitives.Ufixed = () => Numerics.Precision().map(([m, n]) => `ufixed${m}x${n}`);
    Primitives.BytesM = () => Numerics.Bytes().map((m) => `bytes${m}`);
    Primitives.Function = () => fc.constant("function");
    Primitives.Bytes = () => fc.constant("bytes");
    Primitives.String = () => fc.constant("string");
    Primitives.Tuple = () => fc.constant("tuple");
})(Primitives = exports.Primitives || (exports.Primitives = {}));
exports.Primitive = () => fc.oneof(Primitives.Uint(), Primitives.Int(), Primitives.Address(), Primitives.Bool(), Primitives.Fixed(), Primitives.Ufixed(), Primitives.BytesM(), 
// Primitives.Function(), // TODO re-add
Primitives.Bytes(), Primitives.String(), Primitives.Tuple());
exports.Type = fc.memo((n) => n === 0
    ? exports.Primitive()
    : fc.oneof(exports.Primitive(), ArrayFixed(n > 3 ? 3 : n), ArrayDynamic(n)));
const ArrayFixed = fc.memo((n) => {
    const tuple = n <= 1
        ? fc.tuple(exports.Primitive(), fc.integer(1, 256))
        : fc.tuple(exports.Type(), fc.integer(1, 256));
    return tuple.map(([type, length]) => `${type}[${length}]`);
});
const ArrayDynamic = fc.memo((n) => {
    const item = n <= 1 ? exports.Primitive() : exports.Type();
    return item.map((type) => `${type}[]`);
});
const reservedWords = new Set([
    "after",
    "alias",
    "apply",
    "auto",
    "case",
    "copyof",
    "default",
    "define",
    "final",
    "immutable",
    "implements",
    "in",
    "inline",
    "interface",
    "let",
    "macro",
    "match",
    "mutable",
    "null",
    "of",
    "partial",
    "promise",
    "reference",
    "relocatable",
    "sealed",
    "sizeof",
    "static",
    "supports",
    "switch",
    "typedef",
    "typeof",
    "unchecked",
]);
const fakerToArb = (template, transform = change_case_1.camelCase) => {
    return fc
        .integer()
        .noBias()
        .noShrink()
        .map((seed) => {
        faker_1.default.seed(seed);
        return transform(faker_1.default.fake(template));
    })
        .filter((word) => !reservedWords.has(word));
};
exports.ParameterName = () => fc.frequency({ arbitrary: fakerToArb("{{hacker.noun}}"), weight: 9 }, { arbitrary: fc.constant(""), weight: 1 });
exports.EventName = () => fakerToArb("{{hacker.verb}} {{hacker.noun}}", change_case_1.pascalCase);
exports.FunctionName = () => fakerToArb("{{hacker.verb}} {{hacker.noun}}");
exports.TypeRecord = () => exports.Type().chain((type) => type.startsWith("tuple")
    ? fc.record({
        type: fc.constant(type),
        components: fc
            .array(exports.Parameter().filter(({ name }) => name !== ""), { minLength: 1, maxLength: 5 })
            .filter((items) => {
            const names = items
                .map(({ name }) => name)
                .filter((name) => name !== "");
            return names.length === new Set(names).size;
        }),
    })
    : fc.record({
        type: fc.constant(type),
    }));
exports.Parameter = () => fc
    .tuple(fc.record({
    name: exports.ParameterName(),
}), exports.TypeRecord())
    .map((records) => records.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}));
exports.EventParameter = () => fc
    .tuple(fc.record({
    name: exports.ParameterName(),
    indexed: fc.boolean(),
}), exports.TypeRecord())
    .map((records) => records.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}));
exports.Event = () => fc.record({
    type: fc.constant("event"),
    name: exports.EventName(),
    inputs: fc.array(exports.EventParameter(), { maxLength: 10 }).filter((inputs) => {
        if (inputs.filter(({ indexed }) => indexed).length > 3) {
            // only up to 3 params can be indexed
            return false;
        }
        // names that are not blank should be unique
        const names = inputs.map(({ name }) => name).filter((name) => name !== "");
        return names.length === new Set(names).size;
    }),
    anonymous: fc.boolean(),
});
exports.NormalFunction = () => fc
    .tuple(fc.record({
    type: fc.constant("function"),
}, { withDeletedKeys: true }), fc.record({
    name: exports.FunctionName(),
    inputs: fc.array(exports.Parameter(), { maxLength: 10 }).filter((inputs) => {
        // names that are not blank should be unique
        const names = inputs
            .map(({ name }) => name)
            .filter((name) => name !== "");
        return names.length === new Set(names).size;
    }),
}), fc.record({
    outputs: fc.array(exports.Parameter(), { maxLength: 10 }).filter((outputs) => {
        // names that are not blank should be unique
        const names = outputs
            .map(({ name }) => name)
            .filter((name) => name !== "");
        return names.length === new Set(names).size;
    }),
}, { withDeletedKeys: true }), fc
    .tuple(fc.oneof(fc.constant("pure"), fc.constant("view"), fc.constant("nonpayable"), fc.constant("payable")), fc.boolean())
    .map(([stateMutability, includeOptionals]) => !includeOptionals
    ? { stateMutability }
    : {
        stateMutability,
        payable: stateMutability === "payable",
        constant: stateMutability === "view" || stateMutability === "pure",
    }))
    .map((records) => records.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}))
    .filter((entry) => {
    const { inputs, outputs = [] } = entry;
    // names that are not blank should be unique
    const names = [...inputs, ...outputs]
        .map(({ name }) => name)
        .filter((name) => name !== "");
    return names.length === new Set(names).size;
});
exports.ReceiveFunction = () => fc.record({
    type: fc.constant("receive"),
    stateMutability: fc.constant("payable"),
});
exports.FallbackFunction = () => fc
    .tuple(fc.record({
    type: fc.constant("fallback"),
}), fc
    .tuple(fc.oneof(fc.constant("nonpayable"), fc.constant("payable")), fc.boolean())
    .map(([stateMutability, includeOptionals]) => !includeOptionals
    ? { stateMutability }
    : {
        stateMutability,
        payable: stateMutability === "payable",
        constant: stateMutability === "view" || stateMutability === "pure",
    }))
    .map((records) => records.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}));
exports.ConstructorFunction = () => fc
    .tuple(fc.record({
    type: fc.constant("constructor"),
    inputs: fc.array(exports.Parameter()),
}), fc
    .tuple(fc.oneof(fc.constant("nonpayable"), fc.constant("payable")), fc.boolean())
    .map(([stateMutability, includeOptionals]) => !includeOptionals
    ? { stateMutability }
    : {
        stateMutability,
        payable: stateMutability === "payable",
        constant: stateMutability === "view" || stateMutability === "pure",
    }))
    .map((records) => records.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}));
exports.Abi = () => fc
    .tuple(exports.ConstructorFunction(), exports.FallbackFunction(), exports.ReceiveFunction(), fc.array(fc.oneof(exports.NormalFunction(), exports.Event())))
    .chain(([constructor, fallback, receive, entries]) => fc.shuffledSubarray([constructor, fallback, receive, ...entries]));
//# sourceMappingURL=arbitrary.js.map