"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilations = void 0;
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("codec:compilations:utils");
function shimCompilations(inputCompilations, shimmedCompilationIdPrefix = "shimmedcompilation", externalSolidity = false) {
    return inputCompilations.map(({ contracts, sourceIndexes }, compilationIndex) => shimContracts(contracts, sourceIndexes, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`, externalSolidity));
}
exports.shimCompilations = shimCompilations;
/**
 * wrapper around shimArtifactsToCompilation that just returns
 * the result in a one-element array (keeping the old name
 * shimArtifacts for compatibility)
 */
function shimArtifacts(artifacts, files, shimmedCompilationId = "shimmedcompilation", externalSolidity = false) {
    return [
        shimContracts(artifacts, files, shimmedCompilationId, externalSolidity)
    ];
}
exports.shimArtifacts = shimArtifacts;
/**
 * shims a bunch of contracts ("artifacts", though not necessarily)
 * to a compilation.  usually used via one of the above two functions.
 */
function shimContracts(artifacts, files, shimmedCompilationId = "shimmedcompilation", externalSolidity = false) {
    let contracts = [];
    let sources = [];
    let unreliableSourceOrder = false;
    for (let artifact of artifacts) {
        let { contractName, bytecode, sourceMap, deployedBytecode, deployedSourceMap, immutableReferences, sourcePath, source, ast, abi, compiler, generatedSources, deployedGeneratedSources } = artifact;
        if (artifact.contract_name) {
            //just in case
            contractName = artifact.contract_name;
            //dunno what's up w/ the type of contract_name, but it needs coercing
        }
        debug("contractName: %s", contractName);
        let sourceObject = {
            sourcePath,
            source,
            ast: ast,
            compiler
        };
        //ast needs to be coerced because schema doesn't quite match our types here...
        let contractObject = {
            contractName,
            bytecode,
            sourceMap,
            deployedBytecode,
            deployedSourceMap,
            immutableReferences,
            abi,
            compiler
        };
        //if files was passed, trust that to determine the source index
        if (files) {
            const index = files.indexOf(sourcePath);
            debug("sourcePath: %s", sourceObject.sourcePath);
            debug("given index: %d", index);
            debug("sources: %o", sources.map(source => source.sourcePath));
            sources[index] = sourceObject;
            sourceObject.id = index.toString(); //HACK
            contractObject.primarySourceId = index.toString();
            //note: we never set the unreliableSourceOrder flag in this branch;
            //we just trust files.  If files is bad, then, uh, too bad.
        }
        else {
            //if files *wasn't* passed, attempt to determine it from the ast
            let index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons
            ({ index, unreliableSourceOrder } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));
            if (index !== null) {
                sources[index] = Object.assign(Object.assign({}, sourceObject), { id: index.toString() });
                contractObject.primarySourceId = index.toString();
            }
        }
        //now: add internal sources
        for (let { ast, contents, id: index, name } of [
            ...(generatedSources || []),
            ...(deployedGeneratedSources || [])
        ]) {
            const generatedSourceObject = {
                sourcePath: name,
                source: contents,
                ast: ast,
                compiler,
                internal: true
            };
            ({ index, unreliableSourceOrder } = getIndexToAddAt(generatedSourceObject, index, sources, unreliableSourceOrder));
            if (index !== null) {
                sources[index] = Object.assign(Object.assign({}, generatedSourceObject), { id: index.toString() });
            }
        }
        contracts.push(contractObject);
    }
    let compiler;
    if (!unreliableSourceOrder && contracts.length > 0) {
        //if things were actually compiled together, we should just be able
        //to pick an arbitrary one
        compiler = contracts[0].compiler;
    }
    return {
        id: shimmedCompilationId,
        unreliableSourceOrder,
        sources,
        contracts,
        compiler,
        externalSolidity
    };
}
exports.shimContracts = shimContracts;
function sourceIndexForAst(ast) {
    if (!ast) {
        return undefined;
    }
    return parseInt(ast.src.split(":")[2]);
    //src is given as start:length:file.
    //we want just the file.
}
function getContractNode(contract, compilation) {
    const { contractName, sourceMap, deployedSourceMap, primarySourceId } = contract;
    const { unreliableSourceOrder, sources } = compilation;
    let sourcesToCheck;
    //we will attempt to locate the primary source;
    //if we can't find it, we'll just check every source in this
    //compilation.
    if (primarySourceId !== undefined) {
        sourcesToCheck = [
            sources.find(source => source && source.id === primarySourceId)
        ];
    }
    else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {
        let sourceId = extractPrimarySource(deployedSourceMap || sourceMap);
        sourcesToCheck = [sources[sourceId]];
    }
    else {
        //WARNING: if we end up in this case, we could get the wrong contract!
        //(but we shouldn't end up here)
        sourcesToCheck = sources;
    }
    return sourcesToCheck.reduce((foundNode, source) => {
        if (foundNode || !source) {
            return foundNode;
        }
        if (!source.ast || source.ast.nodeType !== "SourceUnit") {
            //don't search Yul sources!
            return undefined;
        }
        return source.ast.nodes.find(node => node.nodeType === "ContractDefinition" && node.name === contractName);
    }, undefined);
}
exports.getContractNode = getContractNode;
/**
 * extract the primary source from a source map
 * (i.e., the source for the first instruction, found
 * between the second and third colons)
 * (this is something of a HACK)
 * NOTE: duplicated from debugger, sorry
 */
function extractPrimarySource(sourceMap) {
    return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);
}
function getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {
    //first: is this already there? only add it if it's not.
    //(we determine this by sourcePath if present, and the actual source
    //contents if not)
    debug("sourcePath: %s", sourceObject.sourcePath);
    debug("given index: %d", index);
    debug("sources: %o", sources.map(source => source.sourcePath));
    if (sources.every(existingSource => existingSource.sourcePath !== sourceObject.sourcePath ||
        ((!sourceObject.sourcePath || sourceObject.internal) &&
            (!existingSource.sourcePath || existingSource.internal) &&
            existingSource.source !== sourceObject.source))) {
        if (unreliableSourceOrder || index === undefined || index in sources) {
            //if we can't add it at the correct spot, set the
            //unreliable source order flag
            debug("collision!");
            unreliableSourceOrder = true;
        }
        //otherwise, just leave things alone
        if (unreliableSourceOrder) {
            //in case of unreliable source order, we'll ignore what indices
            //things are *supposed* to have and just append things to the end
            index = sources.length;
        }
        return {
            index,
            unreliableSourceOrder
        };
    }
    else {
        //return index: null indicates don't add this because it's
        //already present
        debug("already present, not adding");
        return {
            index: null,
            unreliableSourceOrder
        };
    }
}
//# sourceMappingURL=utils.js.map