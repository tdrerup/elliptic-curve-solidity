(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("reselect-tree", [], factory);
	else if(typeof exports === 'object')
		exports["reselect-tree"] = factory();
	else
		root["reselect-tree"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("source-map-support/register");

/***/ }),
/* 2 */,
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(5);

var _assign2 = _interopRequireDefault(_assign);

var _keys = __webpack_require__(6);

var _keys2 = _interopRequireDefault(_keys);

exports.createNestedSelector = createNestedSelector;
exports.createLeaf = createLeaf;
exports.createSelectorTree = createSelectorTree;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

__webpack_require__(1);

var _reselect = __webpack_require__(7);

var _jsonPointer = __webpack_require__(8);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("reselect-tree");

/**
 * Create a single memoized selector for a collection of named sub-selectors.
 * Behaves like `createStructuredSelector` but also allows direct invocation
 * of child selectors.
 *
 * For example:
 *
 *   const shop = createNestedSelector({
 *     items: (state) => state.items,
 *     promos: (state) => state.promos
 *   });
 *
 * Results in three selectors:
 *
 *   shop(state) ==> { items: state.items, promos: state.items }
 *   shop.items(state) => state.items
 *   shop.promos(state) => state.promos
 *
 * Override `rootSelector` to change behavior of top-level (i.e. `shop(state)`
 * in example.)
 *
 * @param {Object} selectors - object description of selector funcs
 * @param {Selector} rootSelector - specify root selector instead of aggregation
 * @return Selector
 */
function createNestedSelector(selectors, rootSelector = null) {
  let selector;

  if (!rootSelector) {
    // unspecified means default to structured aggregation
    selector = (0, _reselect.createStructuredSelector)(selectors);
  } else if (!(rootSelector instanceof Object) || !rootSelector.resultFunc) {
    // rootSelector isn't already a selector, or it's not an object...
    // forward to `createSelector()`
    selector = (0, _reselect.createSelector)(rootSelector);
  } else {
    // otherwise, just use as is
    selector = rootSelector;
  }

  // add properties for child selectors
  (0, _keys2.default)(selectors).forEach(prop => {
    selector[prop] = selectors[prop];
  });

  return selector;
}

class Leaf {
  constructor(deps, selector) {
    this.deps = deps;
    this.selector = selector;
  }

  contextualize(resolve, pointer) {
    let resolved = this.deps.map(dep => {
      if (typeof dep == 'string') {
        if (dep == "") {
          dep = "/";
        }

        const abspath = _resolvePointer(pointer, "..", dep);
        debug("pointer %o", pointer);
        debug("abspath %o", abspath);

        return (...args) => {
          debug("args: %o", args);
          let selector = resolve(abspath);
          debug("resolved selector: %o", selector);
          if (!selector) {
            throw new Error(`Error: Cannot resolve dep ${dep} on ${pointer}`);
          }
          let result = selector.apply(selector, args);
          debug("result: %o", result);
          return result;
        };
      }

      return dep;
    });

    return (0, _reselect.createSelector)(resolved, this.selector);
  }
}

function createLeaf(deps, selector) {
  return new Leaf(deps, selector);
}

class Tree {
  setRoot(root) {
    this.root = root;
  }

  resolve(abspath) {
    var resolved;
    try {
      let parsed = _jsonPointer2.default.parse(abspath);

      let cur = this.root;
      for (let step of parsed) {
        cur = cur[step];
      }

      return cur;
    } catch (e) {
      debug("failed, root: %O", this.root);
      throw e;
    }

    return resolved;
  }
}

function createSelectorTree(root) {
  let tree = new Tree();

  let selector = _createNode(root, tree.resolve.bind(tree), "");

  tree.setRoot(selector);

  return selector;
}

/**
 * Recursively create a selector node in the tree, applying context to nodes
 * as needed.
 */
function _createNode(node, resolve, pointer = "") {
  //based on type of node, operate differently
  if (node instanceof Function) {
    // plain functions are converted to contextualized Leaf nodes
    return createLeaf([state => state], node).contextualize(resolve, pointer);
  } else if (node instanceof Leaf) {
    // explicit leaf nodes just need context resolution for relative deps
    return node.contextualize(resolve, pointer);
  } else if (node instanceof Object) {
    // otherwise, node is an object, so recurse
    const recurse = (key, child) => _createNode(child, resolve, `${pointer}/${key}`);

    let selectors = (0, _assign2.default)({}, ...(0, _entries2.default)(node).map(([key, child]) => ({ [key]: recurse(key, child) })));

    // special-case `_` child nodes override root selector
    const rootSelector = selectors._ || null;

    return createNestedSelector(selectors, rootSelector);
  } else {
    // other types are not allowed
    throw new Error(`Invalid node in selector tree at ${pointer}. ` + `Must be function, leaf, or object. Received: ${node}`);
  }
}

/**
 * Behaves like path.posix.resolve(), ensuring the returned string is a
 * /-separated string with no ".." or ".".
 *
 * Later absolute entries in `paths` (i.e., items that start with `/`)
 * supercede previous entries.
 */
function _resolvePointer(...paths) {
  return paths
  // reduce to /-separated string, ignoring anything before the last-
  // specified absolute path (e.g. ["/a", "/b", "./c"] becomes "/b/./c")
  .reduce((joined, next) => {
    // next child is absolute; discard previous
    if (next.startsWith("/")) {
      return next;
    }

    return `${joined}/${next}`;
  }, "")

  // now, remove .. and .
  .split("/").reduce((resolved, next) => {
    switch (next) {
      case "..":
        return resolved.slice(0, -1);
      case ".":
        return resolved;
      default:
        return resolved.concat(next);
    }
  }, []).join("/");
}

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("reselect");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIndlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2svYm9vdHN0cmFwIDlhNGU1YTRlNmM5YTY2NzI3NTBkIiwiZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwiZXh0ZXJuYWwgXCJzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXJcIiIsImxpYi9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiIiwiZXh0ZXJuYWwgXCJyZXNlbGVjdFwiIiwiZXh0ZXJuYWwgXCJqc29uLXBvaW50ZXJcIiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInJlc2VsZWN0LXRyZWVcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicmVzZWxlY3QtdHJlZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJyZXNlbGVjdC10cmVlXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA5YTRlNWE0ZTZjOWE2NjcyNzUwZCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImRlYnVnXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZGVidWdcIlxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInJlc2VsZWN0LXRyZWVcIik7XG5cbmltcG9ydCBcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuXG4vKipcbiAqIENyZWF0ZSBhIHNpbmdsZSBtZW1vaXplZCBzZWxlY3RvciBmb3IgYSBjb2xsZWN0aW9uIG9mIG5hbWVkIHN1Yi1zZWxlY3RvcnMuXG4gKiBCZWhhdmVzIGxpa2UgYGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcmAgYnV0IGFsc28gYWxsb3dzIGRpcmVjdCBpbnZvY2F0aW9uXG4gKiBvZiBjaGlsZCBzZWxlY3RvcnMuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICBjb25zdCBzaG9wID0gY3JlYXRlTmVzdGVkU2VsZWN0b3Ioe1xuICogICAgIGl0ZW1zOiAoc3RhdGUpID0+IHN0YXRlLml0ZW1zLFxuICogICAgIHByb21vczogKHN0YXRlKSA9PiBzdGF0ZS5wcm9tb3NcbiAqICAgfSk7XG4gKlxuICogUmVzdWx0cyBpbiB0aHJlZSBzZWxlY3RvcnM6XG4gKlxuICogICBzaG9wKHN0YXRlKSA9PT4geyBpdGVtczogc3RhdGUuaXRlbXMsIHByb21vczogc3RhdGUuaXRlbXMgfVxuICogICBzaG9wLml0ZW1zKHN0YXRlKSA9PiBzdGF0ZS5pdGVtc1xuICogICBzaG9wLnByb21vcyhzdGF0ZSkgPT4gc3RhdGUucHJvbW9zXG4gKlxuICogT3ZlcnJpZGUgYHJvb3RTZWxlY3RvcmAgdG8gY2hhbmdlIGJlaGF2aW9yIG9mIHRvcC1sZXZlbCAoaS5lLiBgc2hvcChzdGF0ZSlgXG4gKiBpbiBleGFtcGxlLilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0b3JzIC0gb2JqZWN0IGRlc2NyaXB0aW9uIG9mIHNlbGVjdG9yIGZ1bmNzXG4gKiBAcGFyYW0ge1NlbGVjdG9yfSByb290U2VsZWN0b3IgLSBzcGVjaWZ5IHJvb3Qgc2VsZWN0b3IgaW5zdGVhZCBvZiBhZ2dyZWdhdGlvblxuICogQHJldHVybiBTZWxlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTmVzdGVkU2VsZWN0b3IgKHNlbGVjdG9ycywgcm9vdFNlbGVjdG9yID0gbnVsbCkge1xuICBsZXQgc2VsZWN0b3I7XG5cbiAgaWYgKCFyb290U2VsZWN0b3IpIHtcbiAgICAvLyB1bnNwZWNpZmllZCBtZWFucyBkZWZhdWx0IHRvIHN0cnVjdHVyZWQgYWdncmVnYXRpb25cbiAgICBzZWxlY3RvciA9IGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcihzZWxlY3RvcnMpO1xuXG4gIH0gZWxzZSBpZiAoIShyb290U2VsZWN0b3IgaW5zdGFuY2VvZiBPYmplY3QpIHx8ICFyb290U2VsZWN0b3IucmVzdWx0RnVuYykge1xuICAgIC8vIHJvb3RTZWxlY3RvciBpc24ndCBhbHJlYWR5IGEgc2VsZWN0b3IsIG9yIGl0J3Mgbm90IGFuIG9iamVjdC4uLlxuICAgIC8vIGZvcndhcmQgdG8gYGNyZWF0ZVNlbGVjdG9yKClgXG4gICAgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3Rvcihyb290U2VsZWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwganVzdCB1c2UgYXMgaXNcbiAgICBzZWxlY3RvciA9IHJvb3RTZWxlY3RvcjtcbiAgfVxuXG4gIC8vIGFkZCBwcm9wZXJ0aWVzIGZvciBjaGlsZCBzZWxlY3RvcnNcbiAgT2JqZWN0LmtleXMoc2VsZWN0b3JzKS5mb3JFYWNoKCAocHJvcCkgPT4ge1xuICAgIHNlbGVjdG9yW3Byb3BdID0gc2VsZWN0b3JzW3Byb3BdO1xuICB9KTtcblxuICByZXR1cm4gc2VsZWN0b3I7XG59XG5cbmNsYXNzIExlYWYge1xuICBjb25zdHJ1Y3RvcihkZXBzLCBzZWxlY3Rvcikge1xuICAgIHRoaXMuZGVwcyA9IGRlcHM7XG4gICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICB9XG5cbiAgY29udGV4dHVhbGl6ZShyZXNvbHZlLCBwb2ludGVyKSB7XG4gICAgbGV0IHJlc29sdmVkID0gdGhpcy5kZXBzXG4gICAgICAubWFwKCAoZGVwKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVwID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRlcCA9PSBcIlwiKSB7XG4gICAgICAgICAgICBkZXAgPSBcIi9cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhYnNwYXRoID0gX3Jlc29sdmVQb2ludGVyKHBvaW50ZXIsIFwiLi5cIiwgZGVwKTtcbiAgICAgICAgICBkZWJ1ZyhcInBvaW50ZXIgJW9cIiwgcG9pbnRlcik7XG4gICAgICAgICAgZGVidWcoXCJhYnNwYXRoICVvXCIsIGFic3BhdGgpO1xuXG4gICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFyZ3M6ICVvXCIsIGFyZ3MpO1xuICAgICAgICAgICAgbGV0IHNlbGVjdG9yID0gcmVzb2x2ZShhYnNwYXRoKTtcbiAgICAgICAgICAgIGRlYnVnKFwicmVzb2x2ZWQgc2VsZWN0b3I6ICVvXCIsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEVycm9yOiBDYW5ub3QgcmVzb2x2ZSBkZXAgJHtkZXB9IG9uICR7cG9pbnRlcn1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gc2VsZWN0b3IuYXBwbHkoc2VsZWN0b3IsIGFyZ3MpO1xuICAgICAgICAgICAgZGVidWcoXCJyZXN1bHQ6ICVvXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXA7XG4gICAgICB9KTtcblxuICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcihyZXNvbHZlZCwgdGhpcy5zZWxlY3Rvcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxlYWYoZGVwcywgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIG5ldyBMZWFmKGRlcHMsIHNlbGVjdG9yKTtcbn1cblxuY2xhc3MgVHJlZSB7XG4gIHNldFJvb3Qocm9vdCkge1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gIH1cblxuICByZXNvbHZlKGFic3BhdGgpIHtcbiAgICB2YXIgcmVzb2x2ZWQ7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBwYXJzZWQgPSBqc29ucG9pbnRlci5wYXJzZShhYnNwYXRoKTtcblxuICAgICAgbGV0IGN1ciA9IHRoaXMucm9vdDtcbiAgICAgIGZvciAobGV0IHN0ZXAgb2YgcGFyc2VkKSB7XG4gICAgICAgIGN1ciA9IGN1cltzdGVwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cjtcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKFwiZmFpbGVkLCByb290OiAlT1wiLCB0aGlzLnJvb3QpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yVHJlZSAocm9vdCkge1xuICBsZXQgdHJlZSA9IG5ldyBUcmVlKCk7XG5cbiAgbGV0IHNlbGVjdG9yID0gX2NyZWF0ZU5vZGUocm9vdCwgdHJlZS5yZXNvbHZlLmJpbmQodHJlZSksIFwiXCIpO1xuXG4gIHRyZWUuc2V0Um9vdChzZWxlY3Rvcik7XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNyZWF0ZSBhIHNlbGVjdG9yIG5vZGUgaW4gdGhlIHRyZWUsIGFwcGx5aW5nIGNvbnRleHQgdG8gbm9kZXNcbiAqIGFzIG5lZWRlZC5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZU5vZGUobm9kZSwgcmVzb2x2ZSwgcG9pbnRlciA9IFwiXCIpIHtcbiAgLy9iYXNlZCBvbiB0eXBlIG9mIG5vZGUsIG9wZXJhdGUgZGlmZmVyZW50bHlcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIC8vIHBsYWluIGZ1bmN0aW9ucyBhcmUgY29udmVydGVkIHRvIGNvbnRleHR1YWxpemVkIExlYWYgbm9kZXNcbiAgICByZXR1cm4gY3JlYXRlTGVhZihbc3RhdGUgPT4gc3RhdGVdLCBub2RlKS5jb250ZXh0dWFsaXplKHJlc29sdmUsIHBvaW50ZXIpO1xuXG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIExlYWYpIHtcbiAgICAvLyBleHBsaWNpdCBsZWFmIG5vZGVzIGp1c3QgbmVlZCBjb250ZXh0IHJlc29sdXRpb24gZm9yIHJlbGF0aXZlIGRlcHNcbiAgICByZXR1cm4gbm9kZS5jb250ZXh0dWFsaXplKHJlc29sdmUsIHBvaW50ZXIpO1xuXG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIC8vIG90aGVyd2lzZSwgbm9kZSBpcyBhbiBvYmplY3QsIHNvIHJlY3Vyc2VcbiAgICBjb25zdCByZWN1cnNlID1cbiAgICAgIChrZXksIGNoaWxkKSA9PiBfY3JlYXRlTm9kZShjaGlsZCwgcmVzb2x2ZSwgYCR7cG9pbnRlcn0vJHtrZXl9YCk7XG5cbiAgICBsZXQgc2VsZWN0b3JzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgIC4uLk9iamVjdC5lbnRyaWVzKG5vZGUpXG4gICAgICAgIC5tYXAoIChba2V5LCBjaGlsZF0pID0+ICh7IFtrZXldOiByZWN1cnNlKGtleSwgY2hpbGQpIH0pIClcbiAgICApO1xuXG4gICAgLy8gc3BlY2lhbC1jYXNlIGBfYCBjaGlsZCBub2RlcyBvdmVycmlkZSByb290IHNlbGVjdG9yXG4gICAgY29uc3Qgcm9vdFNlbGVjdG9yID0gc2VsZWN0b3JzLl8gfHwgbnVsbDtcblxuICAgIHJldHVybiBjcmVhdGVOZXN0ZWRTZWxlY3RvcihzZWxlY3RvcnMsIHJvb3RTZWxlY3Rvcik7XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlciB0eXBlcyBhcmUgbm90IGFsbG93ZWRcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBub2RlIGluIHNlbGVjdG9yIHRyZWUgYXQgJHtwb2ludGVyfS4gYCArXG4gICAgICBgTXVzdCBiZSBmdW5jdGlvbiwgbGVhZiwgb3Igb2JqZWN0LiBSZWNlaXZlZDogJHtub2RlfWBcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIHBhdGgucG9zaXgucmVzb2x2ZSgpLCBlbnN1cmluZyB0aGUgcmV0dXJuZWQgc3RyaW5nIGlzIGFcbiAqIC8tc2VwYXJhdGVkIHN0cmluZyB3aXRoIG5vIFwiLi5cIiBvciBcIi5cIi5cbiAqXG4gKiBMYXRlciBhYnNvbHV0ZSBlbnRyaWVzIGluIGBwYXRoc2AgKGkuZS4sIGl0ZW1zIHRoYXQgc3RhcnQgd2l0aCBgL2ApXG4gKiBzdXBlcmNlZGUgcHJldmlvdXMgZW50cmllcy5cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVQb2ludGVyKC4uLnBhdGhzKSB7XG4gIHJldHVybiBwYXRoc1xuICAgIC8vIHJlZHVjZSB0byAvLXNlcGFyYXRlZCBzdHJpbmcsIGlnbm9yaW5nIGFueXRoaW5nIGJlZm9yZSB0aGUgbGFzdC1cbiAgICAvLyBzcGVjaWZpZWQgYWJzb2x1dGUgcGF0aCAoZS5nLiBbXCIvYVwiLCBcIi9iXCIsIFwiLi9jXCJdIGJlY29tZXMgXCIvYi8uL2NcIilcbiAgICAucmVkdWNlKChqb2luZWQsIG5leHQpID0+IHtcbiAgICAgIC8vIG5leHQgY2hpbGQgaXMgYWJzb2x1dGU7IGRpc2NhcmQgcHJldmlvdXNcbiAgICAgIGlmIChuZXh0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYCR7am9pbmVkfS8ke25leHR9YDtcbiAgICB9LCBcIlwiKVxuXG4gICAgLy8gbm93LCByZW1vdmUgLi4gYW5kIC5cbiAgICAuc3BsaXQoXCIvXCIpXG4gICAgLnJlZHVjZSgocmVzb2x2ZWQsIG5leHQpID0+IHtcbiAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICBjYXNlIFwiLi5cIjpcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQuc2xpY2UoMCwgLTEpO1xuICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQuY29uY2F0KG5leHQpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC5qb2luKFwiL1wiKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2VudHJpZXNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2VudHJpZXNcIlxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCJcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCJcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVzZWxlY3RcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZXNlbGVjdFwiXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImpzb24tcG9pbnRlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImpzb24tcG9pbnRlclwiXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3REE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2lDQTtBQWdFQTtBQThCQTtBQUNBO0FBaElBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFOQTtBQUNBO0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQ0E7QUFDQTtBQXVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUFDQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFFQTs7Ozs7O0FDaE5BOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7OztBIiwic291cmNlUm9vdCI6IiJ9