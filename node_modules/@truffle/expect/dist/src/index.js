"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.one = exports.options = exports.has = void 0;
/**
 * Asserts at runtime that `options` contains `key`
 */
function has(options, key) {
    // @ts-ignore to get around the fact that we know nothing about O
    if (options[key] == null) {
        throw new Error(`Expected parameter '${key}' not passed to function.`);
    }
}
exports.has = has;
/**
 * Asserts at runtime that `options` contains all `expectedKeys`
 */
function options(options, expectedKeys) {
    for (const key of expectedKeys) {
        has(options, key);
    }
}
exports.options = options;
/**
 * Asserts at runtime that `options` contains at least one of `expectedKeys`
 *
 * Post-condition: this narrows type of `options` to include _exactly one_ of
 * `expectedKeys`, even though at runtime this accepts more than one key.
 */
function one(options, expectedKeys) {
    const found = expectedKeys.some(key => {
        try {
            has(options, key);
            return true;
        }
        catch (error) {
            if (!error.message.includes(`Expected parameter '${key}' not passed to function.`)) {
                throw error;
            }
            return false;
        }
    });
    // If this doesn't work in all cases, perhaps we should
    // create an expect.onlyOne() function.
    if (!found) {
        throw new Error(`Expected one of the following parameters, but found none: ${expectedKeys.join(", ")}`);
    }
}
exports.one = one;
//# sourceMappingURL=index.js.map