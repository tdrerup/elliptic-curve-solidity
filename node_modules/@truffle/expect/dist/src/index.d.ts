/**
 * Object type O that includes non-nullable keys K
 */
export declare type Has<O extends {}, K extends string> = O & Required<NonNullable<Pick<O, K & keyof O>>>;
/**
 * Object type O that includes exactly one non-nullable value among keys K
 */
export declare type HasOne<O extends {}, K extends string> = O & {
    [N in K]: Has<O, N>;
}[K];
/**
 * Asserts at runtime that `options` contains `key`
 */
export declare function has<O extends {}, K extends string>(options: O, key: K): asserts options is Has<O, K>;
/**
 * Asserts at runtime that `options` contains all `expectedKeys`
 */
export declare function options<O extends {}, K extends string>(options: O, expectedKeys: K[]): asserts options is Has<O, K>;
/**
 * Asserts at runtime that `options` contains at least one of `expectedKeys`
 *
 * Post-condition: this narrows type of `options` to include _exactly one_ of
 * `expectedKeys`, even though at runtime this accepts more than one key.
 */
export declare function one<O extends {}, K extends string>(options: O, expectedKeys: K[]): asserts options is HasOne<O, K>;
