{"version":3,"file":"policies.js","sourceRoot":"","sources":["../../../src/cache/inmemory/policies.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from 'graphql';\n\nimport { Trie } from '@wry/trie';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  FragmentMap,\n  getFragmentFromSelection,\n  isField,\n  getTypenameFromResult,\n  storeKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  argumentsObjectFromField,\n  Reference,\n  isReference,\n  getStoreKeyName,\n  canUseWeakMap,\n  isNonNullObject,\n  stringifyForDisplay,\n} from '../../utilities';\nimport {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n} from './helpers';\nimport { cacheSlot } from './reactiveVars';\nimport { InMemoryCache } from './inMemoryCache';\nimport {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from '../core/types/common';\nimport { WriteContext } from './writeToStore';\n\n// Upgrade to a faster version of the default stable JSON.stringify function\n// used by getStoreKeyName. This function is used when computing storeFieldName\n// strings (when no keyArgs has been configured for a field).\nimport { canonicalStringify } from './object-canon';\n\ngetStoreKeyName.setStringify(canonicalStringify);\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n}\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\ntype KeySpecifier = (string | any[])[];\n\ntype KeyFieldsContext = {\n  typename?: string;\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n  // May be set by the KeyFieldsFunction to report fields that were involved\n  // in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext,\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true,\n  mutationType?: true,\n  subscriptionType?: true,\n\n  fields?: {\n    [fieldName: string]:\n      | FieldPolicy<any>\n      | FieldReadFunction<any>;\n  }\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  },\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyArgsResult = Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult>;\n  merge?: FieldMergeFunction<TExisting, TIncoming> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return spec.args !== void 0 ? spec.args :\n    spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T,\n) => T;\n\nexport type FieldReadFunction<TExisting = any, TReadResult = TExisting> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: FieldFunctionOptions,\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<TExisting = any, TIncoming = TExisting> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: FieldFunctionOptions,\n) => SafeReadonly<TExisting>;\n\nexport const defaultDataIdFromObject = (\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext,\n) => {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n         id !== void 0 ? {  id } :\n        _id !== void 0 ? { _id } :\n        void 0;\n    }\n    // If there is no object.id, fall back to object._id.\n    if (id === void 0) id = _id;\n    if (id !== void 0) {\n      return `${__typename}:${(\n        typeof id === \"number\" ||\n        typeof id === \"string\"\n      ) ? id : JSON.stringify(id)}`;\n    }\n  }\n};\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> =\n  (existing, incoming, { mergeObjects }) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: {\n          keyFn?: KeyArgsFunction;\n          read?: FieldReadFunction<any>;\n          merge?: FieldMergeFunction<any>;\n        };\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> = Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> = Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(private config: {\n    cache: InMemoryCache;\n    dataIdFromObject?: KeyFieldsFunction;\n    possibleTypes?: PossibleTypesMap;\n    typePolicies?: TypePolicies;\n  }) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    selectionSet?: SelectionSetNode,\n    fragmentMap?: FragmentMap,\n  ): [string?, StoreObject?] {\n    // TODO Use an AliasMap here?\n    const typename = selectionSet && fragmentMap\n      ? getTypenameFromResult(object, selectionSet, fragmentMap)\n      : object.__typename;\n\n    // It should be possible to write root Query fields with\n    // writeFragment, using { __typename: \"Query\", ... } as the data, but\n    // it does not make sense to allow the same identification behavior\n    // for the Mutation and Subscription types, since application code\n    // should never be writing directly to (or reading directly from)\n    // those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    const context: KeyFieldsContext = {\n      typename,\n      selectionSet,\n      fragmentMap,\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    while (keyFn) {\n      const specifierOrId = keyFn(object, context);\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach(typename => {\n      const {\n        queryType,\n        mutationType,\n        subscriptionType,\n        ...incoming\n      } = typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(typename: string, incoming: TypePolicy) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean; },\n      merge?: FieldMergeFunction | boolean,\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge :\n        // Pass merge:true as a shorthand for a merge implementation\n        // that returns options.mergeObjects(existing, incoming).\n        merge === true ? mergeTrueFn :\n        // Pass merge:false to make incoming always replace existing\n        // without any warnings about data clobbering.\n        merge === false ? mergeFalseFn :\n        existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn :\n      // Pass an array of strings to use those fields to compute a\n      // composite ID for objects of this typename.\n      Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n      // Pass a function to take full control over identification.\n      typeof keyFields === \"function\" ? keyFields :\n      // Leave existing.keyFn unchanged if above cases fail.\n      existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach(fieldName => {\n        const existing = this.getFieldPolicy(typename, fieldName, true)!;\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn :\n            // Pass an array of strings to use named arguments to\n            // compute a composite identity for the field.\n            Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n            // Pass a function to take full control over field identity.\n            typeof keyArgs === \"function\" ? keyArgs :\n            // Leave existing.keyFn unchanged if above cases fail.\n            existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which,\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(!old || old === which, `Cannot change root ${which} __typename more than once`);\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach(supertype => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtype => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] =\n        this.typePolicies[typename] = Object.create(null);\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its\n      // properties can still be updated directly using addTypePolicies,\n      // but future changes to supertype policies will not be reflected in\n      // this policy, because this code runs at most once per typename.\n      const supertypes = this.supertypeMap.get(typename);\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(supertype => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach(policy => {\n        this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string,\n    createIfMissing: boolean,\n  ): {\n    keyFn?: KeyArgsFunction;\n    read?: FieldReadFunction<any>;\n    merge?: FieldMergeFunction<any>;\n  } | undefined {\n    if (typename) {\n      const fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || (\n        createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean,\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set<string>());\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>,\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes &&\n        this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (supertypeSet &&\n            supertypeSet.size &&\n            workQueue.indexOf(supertypeSet) < 0) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(`Inferring subtype ${typename} of supertype ${supertype}`);\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (needToCheckFuzzySubtypes &&\n            // Start checking fuzzy subtypes only after exhausting all\n            // non-fuzzy subtypes (after the final iteration of the loop).\n            i === workQueue.length - 1 &&\n            // We could wait to compare fragment.selectionSet to result\n            // after we verify the supertype, but this check is often less\n            // expensive than that search, and we will have to do the\n            // comparison anyway whenever we find a potential match.\n            selectionSetMatchesResult(fragment.selectionSet, result!, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    let storeFieldName: KeyArgsResult;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field\n        ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName)\n      ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext,\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(objectOrReference, storeFieldName);\n    const policy = this.getFieldPolicy(options.typename, fieldName, false);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference)\n            ? objectOrReference.__ref\n            : objectOrReference,\n          storeFieldName,\n        ),\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(\n        this.cache,\n        read,\n        [existing, readOptions],\n      ) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined,\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined =\n      this.getFieldPolicy(parentTypename, fieldName, false);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType,\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(\n        context.store,\n      )(existing as StoreObject,\n        incoming as StoreObject);\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(existing, incoming, makeFieldFunctionOptions(\n      this,\n      // Unlike options.readField for read functions, we do not fall\n      // back to the current object if no foreignObjOrRef is provided,\n      // because it's not clear what the current object should be for\n      // merge functions: the (possibly undefined) existing object, or\n      // the incoming object? If you think your merge function needs\n      // to read sibling fields in order to produce a new value for\n      // the current field, you might want to rethink your strategy,\n      // because that's a recipe for making merge behavior sensitive\n      // to the order in which fields are written into the cache.\n      // However, readField(name, ref) is useful for merge functions\n      // that need to deduplicate child objects and references.\n      void 0,\n      { typename,\n        fieldName: field.name.value,\n        field,\n        variables: context.variables },\n      context,\n      storage || Object.create(null),\n    ));\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType,\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n\n    readField<T>(\n      fieldNameOrOptions: string | ReadFieldOptions,\n      from?: StoreObject | Reference,\n    ) {\n      let options: ReadFieldOptions;\n      if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n          fieldName: fieldNameOrOptions,\n          // Default to objectOrReference only when no second argument was\n          // passed for the from parameter, not when undefined is explicitly\n          // passed as the second argument.\n          from: arguments.length > 1 ? from : objectOrReference,\n        };\n      } else if (isNonNullObject(fieldNameOrOptions)) {\n        options = { ...fieldNameOrOptions };\n        // Default to objectOrReference only when fieldNameOrOptions.from is\n        // actually omitted, rather than just undefined.\n        if (!hasOwn.call(fieldNameOrOptions, \"from\")) {\n          options.from = objectOrReference;\n        }\n      } else {\n        invariant.warn(`Unexpected readField arguments: ${\n          stringifyForDisplay(Array.from(arguments))\n        }`);\n        // The readField helper function returns undefined for any missing\n        // fields, so it should also return undefined if the arguments were not\n        // of a type we expected.\n        return;\n      }\n\n      if (__DEV__ && options.from === void 0) {\n        invariant.warn(`Undefined 'from' passed to readField with arguments ${\n          stringifyForDisplay(Array.from(arguments))\n        }`);\n      }\n\n      if (void 0 === options.variables) {\n        options.variables = variables;\n      }\n\n      return policies.readField<T>(options, context);\n    },\n\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache,\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (Array.isArray(existing) || Array.isArray(incoming)) {\n      throw new InvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) &&\n        isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) &&\n          storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) &&\n          isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (storeValueIsStoreObject(existing) &&\n          storeValueIsStoreObject(incoming)) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n\nfunction keyArgsFnFromSpecifier(\n  specifier: KeySpecifier,\n): KeyArgsFunction {\n  return (args, context) => {\n    return args ? `${context.fieldName}:${\n      JSON.stringify(computeKeyObject(args, specifier, false))\n    }` : context.fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier,\n): KeyFieldsFunction {\n  const trie = new Trie<{\n    aliasMap?: AliasMap;\n  }>(canUseWeakMap);\n\n  return (object, context) => {\n    let aliasMap: AliasMap | undefined;\n    if (context.selectionSet && context.fragmentMap) {\n      const info = trie.lookupArray([\n        context.selectionSet,\n        context.fragmentMap,\n      ]);\n      aliasMap = info.aliasMap || (\n        info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap)\n      );\n    }\n\n    const keyObject = context.keyObject =\n      computeKeyObject(object, specifier, true, aliasMap);\n\n    return `${context.typename}:${JSON.stringify(keyObject)}`;\n  };\n}\n\ntype AliasMap = {\n  // Map from store key to corresponding response key. Undefined when there are\n  // no aliased fields in this selection set.\n  aliases?: Record<string, string>;\n  // Map from store key to AliasMap correponding to a child selection set.\n  // Undefined when there are no child selection sets.\n  subsets?: Record<string, AliasMap>;\n};\n\nfunction makeAliasMap(\n  selectionSet: SelectionSetNode,\n  fragmentMap: FragmentMap,\n): AliasMap {\n  let map: AliasMap = Object.create(null);\n  // TODO Cache this work, perhaps by storing selectionSet._aliasMap?\n  const workQueue = new Set([selectionSet]);\n  workQueue.forEach(selectionSet => {\n    selectionSet.selections.forEach(selection => {\n      if (isField(selection)) {\n        if (selection.alias) {\n          const responseKey = selection.alias.value;\n          const storeKey = selection.name.value;\n          if (storeKey !== responseKey) {\n            const aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n        if (selection.selectionSet) {\n          const subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] =\n            makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        const fragment = getFragmentFromSelection(selection, fragmentMap);\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(\n  response: Record<string, any>,\n  specifier: KeySpecifier,\n  strict: boolean,\n  aliasMap?: AliasMap,\n): Record<string, any> {\n  // The order of adding properties to keyObj affects its JSON serialization,\n  // so we are careful to build keyObj in the order of keys given in\n  // specifier.\n  const keyObj = Object.create(null);\n\n  // The lastResponseKey variable tracks keys as seen in actual GraphQL response\n  // objects, potentially affected by aliasing. The lastActualKey variable\n  // tracks the corresponding key after removing aliases.\n  let lastResponseKey: string | undefined;\n  let lastActualKey: string | undefined;\n\n  specifier.forEach(s => {\n    if (Array.isArray(s)) {\n      if (typeof lastActualKey === \"string\" &&\n          typeof lastResponseKey === \"string\") {\n        const subsets = aliasMap && aliasMap.subsets;\n        const subset = subsets && subsets[lastActualKey];\n        keyObj[lastActualKey] =\n          computeKeyObject(response[lastResponseKey], s, strict, subset);\n      }\n    } else {\n      const aliases = aliasMap && aliasMap.aliases;\n      const responseName = aliases && aliases[s] || s;\n      if (hasOwn.call(response, responseName)) {\n        keyObj[lastActualKey = s] = response[lastResponseKey = responseName];\n      } else {\n        invariant(!strict, `Missing field '${responseName}' while computing key fields`);\n        lastResponseKey = lastActualKey = void 0;\n      }\n    }\n  });\n  return keyObj;\n}\n"]}