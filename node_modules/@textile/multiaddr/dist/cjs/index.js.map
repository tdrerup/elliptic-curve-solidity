{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,+CAAgC;AAEhC,SAAgB,aAAa,CAC3B,IAAqC;IAErC,UAAU;IACV,IAAI,IAAI,IAAI,IAAI,EAAE;QAChB,IAAI,GAAG,EAAE,CAAA;KACV;IAED,IAAI,KAAK,GAAe,IAAI,UAAU,CAAC,CAAC,CAAC,CAAA;IAEzC,IAAI,IAAI,YAAY,UAAU,EAAE;QAC9B,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;KAC9B;SAAM,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;QACnC,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAC7C,MAAM,IAAI,KAAK,CAAC,cAAc,IAAI,yBAAyB,CAAC,CAAA;SAC7D;QACD,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;KAC/B;SAAM,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,EAAE;QACvD,YAAY;QACZ,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA,CAAC,wBAAwB;KAC7D;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAA;KAC3E;IACD,OAAO,KAAK,CAAA;AACd,CAAC;AAxBD,sCAwBC;AAED,SAAgB,eAAe,CAAC,KAAiB;IAC/C,OAAO,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC,CAAA;AACnC,CAAC;AAFD,0CAEC;AAED,SAAgB,aAAa,CAAC,KAAiB;IAC7C,MAAM,CAAC,GAAG,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC,CAAA;IACpC,OAAO,KAAK,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAA;AACtC,CAAC;AAHD,sCAGC;AAED,SAAgB,cAAc,CAC5B,KAAiB;IAOjB,MAAM,MAAM,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;IAChD,MAAM,IAAI,GAAG;QACX,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM;QAC7C,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC;QACf,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;QACpB,IAAI,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;KAC1B,CAAA;IACD,OAAO,IAAI,CAAA;AACb,CAAC;AAhBD,wCAgBC","sourcesContent":["import Multiaddr from 'multiaddr'\nimport * as codec from './codec'\n\nexport function bytesFromAddr(\n  addr: string | Uint8Array | Multiaddr,\n): Uint8Array {\n  // default\n  if (addr == null) {\n    addr = ''\n  }\n\n  let bytes: Uint8Array = new Uint8Array(0)\n\n  if (addr instanceof Uint8Array) {\n    bytes = codec.fromBytes(addr)\n  } else if (typeof addr === 'string') {\n    if (addr.length > 0 && addr.charAt(0) !== '/') {\n      throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n    }\n    bytes = codec.fromString(addr)\n  } else if (addr.bytes && addr.protos && addr.protoCodes) {\n    // Multiaddr\n    bytes = codec.fromBytes(addr.bytes) // validate + copy bytes\n  } else {\n    throw new Error('addr must be a string, Uint8Array, or another Multiaddr')\n  }\n  return bytes\n}\n\nexport function stringFromBytes(bytes: Uint8Array): string {\n  return codec.bytesToString(bytes)\n}\n\nexport function bytesToTuples(bytes: Uint8Array): [number, string | number][] {\n  const t = codec.bytesToTuples(bytes)\n  return codec.tuplesToStringTuples(t)\n}\n\nexport function bytesToOptions(\n  bytes: Uint8Array,\n): {\n  family: string\n  host: string\n  transport: string\n  port: number\n} {\n  const parsed = stringFromBytes(bytes).split('/')\n  const opts = {\n    family: parsed[1] === 'ip4' ? 'ipv4' : 'ipv6',\n    host: parsed[2],\n    transport: parsed[3],\n    port: parseInt(parsed[4]),\n  }\n  return opts\n}\n"]}