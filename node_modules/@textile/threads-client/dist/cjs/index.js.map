{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module @textile/threads-client\n */\nimport { grpc } from '@improbable-eng/grpc-web'\nimport { UnaryOutput } from '@improbable-eng/grpc-web/dist/typings/unary'\nimport { Context, ContextInterface, defaultHost } from '@textile/context'\nimport { Identity } from '@textile/crypto'\nimport { WebsocketTransport } from '@textile/grpc-transport'\nimport {\n  bytesFromAddr,\n  bytesToOptions,\n  bytesToTuples,\n  stringFromBytes,\n} from '@textile/multiaddr'\nimport { KeyInfo, ThreadKey, UserAuth } from '@textile/security'\nimport * as pb from '@textile/threads-client-grpc/threads_pb'\nimport {\n  API,\n  APIGetToken,\n  APIListen,\n} from '@textile/threads-client-grpc/threads_pb_service'\nimport { ThreadID } from '@textile/threads-id'\nimport 'fastestsmallesttextencoderdecoder'\nimport toJsonSchema, { JSONSchema3or4 } from 'to-json-schema'\nimport {\n  ComparisonJSON,\n  CriterionJSON,\n  Event,\n  Filter,\n  Patch,\n  PatchType,\n  Query,\n  QueryJSON,\n  ReadTransaction,\n  SortJSON,\n  ValueJSON,\n  Where,\n  WriteTransaction,\n} from './models'\n\nexport {\n  Filter,\n  Query,\n  Where,\n  WriteTransaction,\n  ReadTransaction,\n  QueryJSON,\n  ValueJSON,\n  ComparisonJSON,\n  CriterionJSON,\n  SortJSON,\n  JSONSchema3or4,\n  Event,\n  Patch,\n  PatchType,\n}\n\nfunction isEmpty(obj: any) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object\n}\n\nexport function getFunctionBody(\n  fn: ((...args: any[]) => any) | string,\n): string {\n  // https://stackoverflow.com/a/25229488/1256988\n  function removeCommentsFromSource(str: string) {\n    return str.replace(\n      /(?:\\/\\*(?:[\\s\\S]*?)\\*\\/)|(?:([\\s;])+\\/\\/(?:.*)$)/gm,\n      '$1',\n    )\n  }\n  const s = removeCommentsFromSource(fn.toString())\n  return s.substring(s.indexOf('{') + 1, s.lastIndexOf('}'))\n}\n\n/**\n * CollectionConfig is the configuration options for creating and updating a Collection.\n * It supports the following configuration options:\n *   - Name: The name of the collection, e.g, \"Animals\" (must be unique per DB).\n *   - Schema: A JSON Schema), which is used for instance validation.\n *   - Indexes: An optional list of index configurations, which define how instances are indexed.\n *   - WriteValidator: An optional JavaScript (ECMAScript 5.1) function that is used to validate\n *     instances on write.\n *   - ReadFilter: An optional JavaScript (ECMAScript 5.1) function that is used to filter\n *     instances on read.\n *\n * The `writeValidator` function receives three arguments:\n *   - writer: The multibase-encoded public key identity of the writer.\n *   - event: An object describing the update event (see core.Event).\n *   - instance: The current instance as a JavaScript object before the update event is applied.\n *\n * A falsy return value indicates a failed validation. Note that the function arguments must\n * be named as documented here (writer, event, instance). These functions run in a secure sandbox\n * where these argument names are specified.\n *\n * Having access to writer, event, and instance opens the door to a variety of app-specific logic.\n * Textile Buckets file-level access roles are implemented in part with a write validator.\n *\n * The `readFilter` function receives three arguments:\n *   - reader: The multibase-encoded public key identity of the reader.\n *   - instance: The current instance as a JavaScript object.\n *\n * The function must return a JavaScript object. Most implementations will modify and return the\n * current instance. Note that the function arguments must be named as documented here (reader,\n * instance). These functions run in a secure sandbox where these argument names are specified.\n * Like write validation, read filtering opens the door to a variety of app-specific logic.\n * Textile Buckets file-level access roles are implemented in part with a read filter.\n */\nexport interface CollectionConfig<W = any, R = W> {\n  name: string\n  schema?: JSONSchema3or4 | any // JSONSchema is preferred but any works\n  indexes?: pb.Index.AsObject[]\n  writeValidator?:\n    | ((writer: string, event: Event, instance: W) => boolean)\n    | string\n  readFilter?: ((reader: string, instance: R) => R) | string\n}\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nexport function maybeLocalAddr(ip: string): boolean | RegExpMatchArray {\n  return (\n    ['localhost', '', '::1'].includes(ip) ||\n    ip.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/) ||\n    ip.startsWith('192.168.') ||\n    ip.startsWith('10.0.') ||\n    ip.endsWith('.local')\n  )\n}\n\nexport enum Action {\n  CREATE = 0,\n  SAVE,\n  DELETE,\n}\n\nexport interface Update<T = unknown> {\n  instance: T | undefined\n  collectionName: string\n  instanceID: string\n  action: Action\n}\n\n/**\n * DBInfo contains joining/sharing information for a Thread/DB.\n */\nexport interface DBInfo {\n  /**\n   * The Thread Key, encoded as a base32 string.\n   * @see {@link ThreadKey} for details.\n   */\n  key: string\n  /**\n   * The Multiaddrs for a peer hosting the given Thread/DB.\n   */\n  addrs: string[]\n}\n\n/**\n * Client is a web-gRPC wrapper client for communicating with a webgRPC-enabled Threads server.\n * This client library can be used to interact with a local or remote Textile gRPC-service\n * It is a wrapper around Textile Thread's 'DB' API, which is defined here:\n * https://github.com/textileio/go-threads/blob/master/api/pb/api.proto.\n *\n * @example\n * ```typescript\n * import {Client, Identity, UserAuth} from '@textile/threads'\n *\n * async function setupDB(auth: UserAuth, identity: Identity) {\n *   // Initialize the client\n *   const client = Client.withUserAuth(auth)\n *\n *   // Connect the user to your API\n *   const userToken = await client.getToken(identity)\n *\n *   // Create a new DB\n *   const threadID = await client.newDB(undefined, 'nasa')\n *\n *   // Create a new Collection from an Object\n *   const buzz = {\n *     name: 'Buzz',\n *     missions: 2,\n *     _id: '',\n *   }\n *   await client.newCollectionFromObject(threadID, buzz, { name: 'astronauts' })\n *\n *   // Store the buzz object in the new collection\n *   await client.create(threadID, 'astronauts', [buzz])\n *\n *   return threadID\n * }\n * ```\n */\nexport class Client {\n  public serviceHost: string\n  public rpcOptions: grpc.RpcOptions\n  /**\n   * Creates a new gRPC client instance for accessing the Textile Threads API.\n   * @param context The context to use for interacting with the APIs. Can be modified later.\n   * @param debug Should we run in debug mode. Defaults to false.\n   */\n  constructor(public context: ContextInterface = new Context(), debug = false) {\n    this.serviceHost = context.host\n    this.rpcOptions = {\n      transport: WebsocketTransport(),\n      debug,\n    }\n  }\n\n  /**\n   * Create a new gRPC client instance from a supplied user auth object.\n   * Assumes all default gRPC settlings. For customization options, use a context object directly.\n   * The callback method will automatically refresh expiring credentials.\n   * @param auth The user auth object or an async callback that returns a user auth object.\n   * @example\n   * ```typescript\n   * import {UserAuth, Client} from '@textile/threads'\n   *\n   * function create (auth: UserAuth) {\n   *   return Client.withUserAuth(auth)\n   * }\n   * ```\n   * @example\n   * ```typescript\n   * import {UserAuth, Client} from '@textile/threads'\n   *\n   * function setCallback (callback: () => Promise<UserAuth>) {\n   *   return Client.withUserAuth(callback)\n   * }\n   * ```\n   */\n  static withUserAuth(\n    auth: UserAuth | (() => Promise<UserAuth>),\n    host = defaultHost,\n    debug = false,\n  ): Client {\n    const context =\n      typeof auth === 'object'\n        ? Context.fromUserAuth(auth, host)\n        : Context.fromUserAuthCallback(auth, host)\n    return new Client(context, debug)\n  }\n\n  /**\n   * Create a new gRPC client instance from a supplied key and secret\n   * @param key The KeyInfo object containing {key: string, secret: string, type: 0}. 0 === User Group Key, 1 === Account Key\n   * @param host The remote gRPC host to connect with. Should be left as default.\n   * @param debug Whether to run in debug mode. Defaults to false.\n   * @example\n   * ```typescript\n   * import {KeyInfo, Client} from '@textile/threads'\n   *\n   * async function create (keyInfo: KeyInfo) {\n   *   return await Client.withKeyInfo(keyInfo)\n   * }\n   * ```\n   */\n  static async withKeyInfo(\n    key: KeyInfo,\n    host = defaultHost,\n    debug = false,\n  ): Promise<Client> {\n    return new Client(await new Context(host).withKeyInfo(key), debug)\n  }\n\n  /**\n   * Obtain a token per user (identity) for interacting with the remote API.\n   * @param identity A user identity to use for creating records in the database. A random identity\n   * can be created with `Client.randomIdentity(), however, it is not easy/possible to migrate\n   * identities after the fact. Please store or otherwise persist any identity information if\n   * you wish to retrieve user data later, or use an external identity provider.\n   * @param ctx Context object containing web-gRPC headers and settings.\n   * @example\n   * ```typescript\n   * import {Client, Identity} from '@textile/threads'\n   *\n   * async function newToken (client: Client, user: Identity) {\n   *   // Token is added to the client connection at the same time\n   *   const token = await client.getToken(user)\n   *   return token\n   * }\n   * ```\n   */\n  getToken(identity: Identity, ctx?: ContextInterface): Promise<string> {\n    return this.getTokenChallenge(\n      identity.public.toString(),\n      async (challenge: Uint8Array) => {\n        return identity.sign(challenge)\n      },\n      ctx,\n    )\n  }\n\n  /**\n   * Obtain a token per user (identity) for interacting with the remote API.\n   * @param publicKey The public key of a user identity to use for creating records in the database.\n   * A random identity can be created with `Client.randomIdentity(), however, it is not\n   * easy/possible to migrate identities after the fact. Please store or otherwise persist any\n   * identity information if you wish to retrieve user data later, or use an external identity\n   * provider.\n   * @param callback A callback function that takes a `challenge` argument and returns a signed\n   * message using the input challenge and the private key associated with `publicKey`.\n   * @param ctx Context object containing web-gRPC headers and settings.\n   * @remarks `publicKey` must be the corresponding public key of the private key used in `callback`.\n   */\n  getTokenChallenge(\n    publicKey: string,\n    callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>,\n    ctx?: ContextInterface,\n  ): Promise<string> {\n    const client = grpc.client<\n      pb.GetTokenRequest,\n      pb.GetTokenReply,\n      APIGetToken\n    >(API.GetToken, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    })\n    return new Promise<string>((resolve, reject) => {\n      let token = ''\n      client.onMessage(async (message: pb.GetTokenReply) => {\n        if (message.hasChallenge()) {\n          const challenge = message.getChallenge_asU8()\n          const signature = await callback(challenge)\n          const req = new pb.GetTokenRequest()\n          req.setSignature(signature)\n          client.send(req)\n          client.finishSend()\n        } else if (message.hasToken()) {\n          token = message.getToken()\n        }\n      })\n      client.onEnd((\n        code: grpc.Code,\n        message: string /** trailers: grpc.Metadata */,\n      ) => {\n        client.close()\n        if (code === grpc.Code.OK) {\n          this.context.withToken(token)\n          resolve(token)\n        } else {\n          reject(new Error(message))\n        }\n      })\n      const req = new pb.GetTokenRequest()\n      req.setKey(publicKey)\n      this.context.toMetadata(ctx).then((metadata) => {\n        client.start(metadata)\n        client.send(req)\n      })\n    })\n  }\n\n  /**\n   * newDB creates a new store on the remote node.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the database\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function createDB (client: Client) {\n   *   const threadID: ThreadID = await client.newDB()\n   *   return threadID\n   * }\n   * ```\n   */\n  public newDB(threadID?: ThreadID, name?: string): Promise<ThreadID> {\n    const dbID = threadID ?? ThreadID.fromRandom()\n    const req = new pb.NewDBRequest()\n    req.setDbid(dbID.toBytes())\n    if (name !== undefined) {\n      this.context.withThreadName(name)\n      req.setName(name)\n    }\n    return this.unary(API.NewDB, req, () => {\n      // Update our context with out new thread id\n      this.context.withThread(dbID.toString())\n      return dbID\n    })\n  }\n\n  /**\n   * open creates and enters a new store on the remote node.\n   * @param threadID the ID of the database\n   * @param name The human-readable name for the database\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function openDB (client: Client, threadID: ThreadID) {\n   *   await client.open(threadID)\n   * }\n   * ```\n   */\n  public async open(threadID: ThreadID, name?: string): Promise<void> {\n    const req = new pb.ListDBsRequest()\n    // Check if we already have this thread on the client...\n    const found = await this.unary(API.ListDBs, req, (res: pb.ListDBsReply) => {\n      for (const db of res.getDbsList()) {\n        const id = ThreadID.fromBytes(db.getDbid_asU8())\n        if (id === threadID) {\n          this.context.withThread(threadID.toString())\n          return true\n        }\n      }\n      return false\n    })\n    // If yes, use that one...\n    if (found) return\n    // Otherwise, try to create a new one\n    await this.newDB(threadID, name)\n    this.context.withThread(threadID.toString())\n  }\n\n  /**\n   * Deletes an entire DB.\n   * @param threadID the ID of the database.\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function deleteDB (client: Client, threadID: ThreadID) {\n   *   await client.deleteDB(threadID)\n   *   return\n   * }\n   * ```\n   */\n  public deleteDB(threadID: ThreadID): Promise<void> {\n    const req = new pb.DeleteDBRequest()\n    req.setDbid(threadID.toBytes())\n    return this.unary(API.DeleteDB, req)\n  }\n\n  /**\n   * Lists all known DBs.\n   */\n  public listDBs(): Promise<Array<{ id: string; name?: string }>> {\n    const req = new pb.ListDBsRequest()\n    return this.unary(API.ListDBs, req, (res: pb.ListDBsReply) => {\n      const dbs: Array<{ id: string; name?: string }> = []\n      for (const db of res.getDbsList()) {\n        const id = ThreadID.fromBytes(db.getDbid_asU8()).toString()\n        dbs.push({\n          id,\n          name: db.getInfo()?.getName(),\n        })\n      }\n      return dbs\n    })\n  }\n\n  /**\n   * Lists the collections in a thread\n   * @param thread the ID of the database\n   */\n  public listCollections(\n    thread: ThreadID,\n  ): Promise<Array<pb.GetCollectionInfoReply.AsObject>> {\n    const req = new pb.ListCollectionsRequest()\n    req.setDbid(thread.toBytes())\n    return this.unary(\n      API.ListCollections,\n      req,\n      (res: pb.ListCollectionsReply) => res.toObject().collectionsList,\n    )\n  }\n\n  /**\n   * newCollection registers a new collection schema under the given name.\n   * The schema must be a valid json-schema.org schema, and can be a JSON string or object.\n   * @param threadID the ID of the database\n   * @param config A configuration object for the collection. See {@link CollectionConfig}. Note\n   * that the validator and filter functions can also be provided as strings.\n   *\n   * @example\n   * Create a new astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const astronauts = {\n   *   title: \"Astronauts\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: {\n   *       type: \"string\",\n   *       description: \"The instance's id.\",\n   *     },\n   *     name: {\n   *       type: \"string\",\n   *       description: \"The astronauts name.\",\n   *     },\n   *     missions: {\n   *       description: \"The number of missions.\",\n   *       type: \"integer\",\n   *       minimum: 0,\n   *     },\n   *   },\n   * }\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, { name: 'astronauts', schema: astronauts })\n   * }\n   * ```\n   * @example\n   * Create a collection with writeValidator and readFilter functions\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const schema = {\n   *   title: \"Person\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: { type: \"string\" },\n   *     name: { type: \"string\" },\n   *     age: { type: \"integer\" },\n   *   },\n   * }\n   *\n   * // We'll create a helper interface for type-safety\n   * interface Person {\n   *   _id: string\n   *   age: number\n   *   name: string\n   * }\n   *\n   * const writeValidator = (writer: string, event: any, instance: Person) => {\n   *   var type = event.patch.type\n   *   var patch = event.patch.json_patch\n   *   switch (type) {\n   *     case \"delete\":\n   *       if (writer != \"the_boss\") {\n   *         return false // Not the boss? No deletes for you.\n   *       }\n   *     default:\n   *       return true\n   *   }\n   * }\n   *\n   * const readFilter = (reader: string, instance: Person) => {\n   *   if (instance.age > 50) {\n   *     delete instance.age // Let's just hide their age for them ;)\n   *   }\n   *   return instance\n   * }\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, {\n   *     name: 'Person', schema, writeValidator, readFilter\n   *   })\n   * }\n   * ```\n   */\n  public newCollection(\n    threadID: ThreadID,\n    config: CollectionConfig,\n  ): Promise<void> {\n    const req = new pb.NewCollectionRequest()\n    const conf = new pb.CollectionConfig()\n    conf.setName(config.name)\n    if (config.schema === undefined || isEmpty(config.schema)) {\n      // We'll use our default schema\n      config.schema = { properties: { _id: { type: 'string' } } }\n    }\n    conf.setSchema(encoder.encode(JSON.stringify(config.schema)))\n\n    if (config.writeValidator) {\n      conf.setWritevalidator(getFunctionBody(config.writeValidator))\n    }\n\n    if (config.readFilter) {\n      conf.setReadfilter(getFunctionBody(config.readFilter))\n    }\n\n    const idx: pb.Index[] = []\n    for (const item of config.indexes ?? []) {\n      const index = new pb.Index()\n      index.setPath(item.path)\n      index.setUnique(item.unique)\n      idx.push(index)\n    }\n    conf.setIndexesList(idx)\n    req.setDbid(threadID.toBytes())\n    req.setConfig(conf)\n    return this.unary(API.NewCollection, req)\n  }\n\n  /**\n   * newCollectionFromObject creates and registers a new collection under the given name.\n   * The input object must be serializable to JSON, and contain only json-schema.org types.\n   * @param threadID the ID of the database\n   * @param obj The actual object to attempt to extract a schema from.\n   * @param config A configuration object for the collection. See {@link CollectionConfig}.\n   *\n   * @example\n   * Change a new astronauts collection based of Buzz\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function newCollection (client: Client, threadID: ThreadID) {\n   *   const buzz = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *   return await client.newCollectionFromObject(threadID, buzz, { name: 'astronauts' })\n   * }\n   * ```\n   */\n  public newCollectionFromObject(\n    threadID: ThreadID,\n    obj: Record<string, any>,\n    config: Omit<CollectionConfig, 'schema'>,\n  ): Promise<void> {\n    const schema: JSONSchema3or4 = toJsonSchema(obj)\n    return this.newCollection(threadID, { ...config, schema })\n  }\n\n  /**\n   * updateCollection updates an existing collection.\n   * Currently, updates can include name and schema.\n   * @todo Allow update of indexing information.\n   * @param threadID the ID of the database\n   * @param config A configuration object for the collection. See {@link CollectionConfig}.\n   *\n   * @example\n   * Change the name of our astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * const astronauts = {\n   *   title: \"Astronauts\",\n   *   type: \"object\",\n   *   required: [\"_id\"],\n   *   properties: {\n   *     _id: {\n   *       type: \"string\",\n   *       description: \"The instance's id.\",\n   *     },\n   *     name: {\n   *       type: \"string\",\n   *       description: \"The astronauts name.\",\n   *     },\n   *     missions: {\n   *       description: \"The number of missions.\",\n   *       type: \"integer\",\n   *       minimum: 0,\n   *     },\n   *   },\n   * }\n   *\n   * async function changeName (client: Client, threadID: ThreadID) {\n   *   return await client.updateCollection(threadID, { name: 'toy-story-characters', schema: astronauts })\n   * }\n   * ```\n   */\n  public updateCollection(\n    threadID: ThreadID,\n    // Everything except \"name\" is optional here\n    config: CollectionConfig,\n  ): Promise<void> {\n    const req = new pb.UpdateCollectionRequest()\n    const conf = new pb.CollectionConfig()\n    conf.setName(config.name)\n    if (config.schema === undefined || isEmpty(config.schema)) {\n      // We'll use our default schema\n      config.schema = { properties: { _id: { type: 'string' } } }\n    }\n    conf.setSchema(encoder.encode(JSON.stringify(config.schema)))\n    if (config.writeValidator) {\n      conf.setWritevalidator(getFunctionBody(config.writeValidator))\n    }\n    if (config.readFilter) {\n      conf.setReadfilter(getFunctionBody(config.readFilter))\n    }\n    const idx: pb.Index[] = []\n    for (const item of config.indexes ?? []) {\n      const index = new pb.Index()\n      index.setPath(item.path)\n      index.setUnique(item.unique)\n      idx.push(index)\n    }\n    conf.setIndexesList(idx)\n    req.setDbid(threadID.toBytes())\n    req.setConfig(conf)\n    return this.unary(API.UpdateCollection, req)\n  }\n\n  /**\n   * Deletes an existing collection.\n   * @param threadID the ID of the database.\n   * @param name The human-readable name for the collection.\n   * @param schema The actual json-schema.org compatible schema object.\n   * @example\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function deleteAstronauts (client: Client, thread: ThreadID) {\n   *   await client.deleteCollection(thread, 'astronauts')\n   *   return\n   * }\n   * ```\n   */\n  public deleteCollection(threadID: ThreadID, name: string): Promise<void> {\n    const req = new pb.DeleteCollectionRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    return this.unary(API.DeleteCollection, req)\n  }\n\n  /**\n   * Returns an existing indexes for a collection.\n   * @param threadID the ID of the database.\n   * @param name The human-readable name for the collection.\n   *\n   * @example\n   * Return a set of indexes for our astronauts collection\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function getIndexes (client: Client, threadID: ThreadID) {\n   *   return await client.getCollectionIndexes(threadID, 'astronauts')\n   * }\n   * ```\n   */\n  public getCollectionIndexes(\n    threadID: ThreadID,\n    name: string,\n  ): Promise<pb.Index.AsObject[]> {\n    const req = new pb.GetCollectionIndexesRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    return this.unary(\n      API.GetCollectionIndexes,\n      req,\n      (res: pb.GetCollectionIndexesReply) => res.toObject().indexesList,\n    )\n  }\n\n  public getCollectionInfo(\n    threadID: ThreadID,\n    name: string,\n  ): Promise<CollectionConfig> {\n    const req = new pb.GetCollectionInfoRequest()\n    req.setDbid(threadID.toBytes())\n    req.setName(name)\n    return this.unary(\n      API.GetCollectionInfo,\n      req,\n      (res: pb.GetCollectionInfoReply) => {\n        const result: CollectionConfig = {\n          schema: JSON.parse(decoder.decode(res.getSchema_asU8())),\n          name: res.getName(),\n          indexes: res.getIndexesList().map((index) => index.toObject()),\n          // We'll always return strings in this case for safety reasons\n          writeValidator: res.getWritevalidator(),\n          readFilter: res.getReadfilter(),\n        }\n        return result\n      },\n    )\n  }\n\n  /**\n   * newDBFromAddr initializes the client with the given store, connecting to the given\n   * thread address (database). It should be called before any operation on the store, and is an\n   * alternative to start, which creates a local store. newDBFromAddr should also include the\n   * read/follow key, which should be a Uint8Array or base32-encoded string.\n   * @remarks\n   * See getDBInfo for a possible source of the address and keys. See {@link ThreadKey} for\n   * information about thread keys.\n   * @param address The address for the thread with which to connect.\n   * Should be of the form /ip4/<url/ip-address>/tcp/<port>/p2p/<peer-id>/thread/<thread-id>\n   * @param key The set of keys to use to connect to the database\n   * @param collections Array of CollectionConfig objects for seeding the DB with collections.\n   */\n  public newDBFromAddr(\n    address: string,\n    key: string | Uint8Array,\n    collections?: Array<CollectionConfig>,\n  ): Promise<ThreadID> {\n    const req = new pb.NewDBFromAddrRequest()\n    const addr = bytesFromAddr(address)\n    req.setAddr(addr)\n    // Should always be encoded string, but might already be bytes\n    req.setKey(\n      typeof key === 'string' ? ThreadKey.fromString(key).toBytes() : key,\n    )\n    if (collections !== undefined) {\n      req.setCollectionsList(\n        collections.map((c) => {\n          const config = new pb.CollectionConfig()\n          config.setName(c.name)\n          config.setSchema(encoder.encode(JSON.stringify(c.schema)))\n          const { indexes } = c\n          if (indexes !== undefined) {\n            const idxs = indexes.map((idx) => {\n              const index = new pb.Index()\n              index.setPath(idx.path)\n              index.setUnique(idx.unique)\n              return index\n            })\n            config.setIndexesList(idxs)\n          }\n          return config\n        }),\n      )\n    }\n    return this.unary(API.NewDBFromAddr, req, (/** res: pb.NewDBReply */) => {\n      // Hacky way to extract threadid from addr that succeeded\n      // TODO: Return this directly from the gRPC API on the go side?\n      const result = bytesToTuples(req.getAddr_asU8()).filter(\n        ([key]) => key === 406,\n      )\n      return ThreadID.fromString(result[0][1] as string)\n    })\n  }\n\n  /**\n   * Connect client to an existing database using information in the DBInfo object\n   * This should be called before any operation on the store, and is an alternative\n   * to open, which re-opens a database already opened by the user.\n   * @remarks This is a helper method around newDBFromAddr, which takes the 'raw' output\n   * from getDBInfo. See getDBInfo for a possible source of the address and keys.\n   * @param info The output from a call to getDBInfo on a separate peer.\n   * @param includeLocal Whether to try dialing addresses that appear to be on the local host.\n   * Defaults to false, preferring to add from public ip addresses.\n   * @param collections Array of `name` and JSON schema pairs for seeding the DB with collections.\n   *\n   * @example\n   * Get DB info and use DB info to join an existing remote thread (e.g. invited)\n   * ```typescript\n   * import {Client, DBInfo, ThreadID} from '@textile/threads'\n   *\n   * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {\n   *   return await client.getDBInfo(threadID)\n   * }\n   *\n   * async function joinFromInfo (client: Client, info: DBInfo) {\n   *   return await client.joinFromInfo(info)\n   * }\n   * ```\n   */\n  public joinFromInfo(\n    info: DBInfo,\n    includeLocal = false,\n    collections?: Array<CollectionConfig>,\n  ): Promise<ThreadID> {\n    const req = new pb.NewDBFromAddrRequest()\n    const filtered = info.addrs\n      .map(bytesFromAddr)\n      .filter(\n        (addr) => includeLocal || !maybeLocalAddr(bytesToOptions(addr).host),\n      )\n    for (const addr of filtered) {\n      req.setAddr(addr)\n      // Should always be encoded string, but might already be bytes\n      req.setKey(\n        typeof info.key === 'string'\n          ? ThreadKey.fromString(info.key).toBytes()\n          : info.key,\n      )\n      if (collections !== undefined) {\n        req.setCollectionsList(\n          collections.map((c) => {\n            const config = new pb.CollectionConfig()\n            config.setName(c.name)\n            config.setSchema(encoder.encode(JSON.stringify(c.schema)))\n            const { indexes } = c\n            if (indexes !== undefined) {\n              const idxs = indexes.map((idx) => {\n                const index = new pb.Index()\n                index.setPath(idx.path)\n                index.setUnique(idx.unique)\n                return index\n              })\n              config.setIndexesList(idxs)\n            }\n            return config\n          }),\n        )\n      }\n      // Try to add addrs one at a time, if one succeeds, we are done.\n      return this.unary(API.NewDBFromAddr, req, () => {\n        // Hacky way to extract threadid from addr that succeeded\n        // @todo: Return this directly from the gRPC API?\n        const result = bytesToTuples(req.getAddr_asU8()).filter(\n          ([key]) => key === 406,\n        )\n        return ThreadID.fromString(result[0][1] as string)\n      })\n    }\n    throw new Error('No viable addresses for dialing')\n  }\n\n  /**\n   * Returns a DBInfo objection containing metadata required to invite other peers to join a given thread.\n   * @param threadID the ID of the database\n   * @returns An object with an encoded thread key, and a list of multiaddrs.\n   *\n   * @example\n   * Get DB info and use DB info to join an existing remote thread (e.g. invited)\n   * ```typescript\n   * import {Client, DBInfo, ThreadID} from '@textile/threads'\n   *\n   * async function getInfo (client: Client, threadID: ThreadID): Promise<DBInfo> {\n   *   return await client.getDBInfo(threadID)\n   * }\n   *\n   * async function joinFromInfo (client: Client, info: DBInfo) {\n   *   return await client.joinFromInfo(info)\n   * }\n   * ```\n   */\n  public getDBInfo(threadID: ThreadID): Promise<DBInfo> {\n    const req = new pb.GetDBInfoRequest()\n    req.setDbid(threadID.toBytes())\n    return this.unary(API.GetDBInfo, req, (res: pb.GetDBInfoReply) => {\n      const key = ThreadKey.fromBytes(res.getKey_asU8())\n      const addrs: string[] = []\n      for (const addr of res.getAddrsList()) {\n        const address = stringFromBytes(addr as Uint8Array)\n        addrs.push(address)\n      }\n      return { key: key.toString(), addrs }\n    })\n  }\n\n  /**\n   * Creates a new model instance in the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   *\n   * @example\n   * Create a new entry in our collection\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function createBuzz (client: Client, threadID: ThreadID) {\n   *   const buzz: Astronaut = {\n   *     name: 'Buzz',\n   *     missions: 2,\n   *     _id: '',\n   *   }\n   *\n   *   await client.create(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public create(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[],\n  ): Promise<string[]> {\n    const req = new pb.CreateRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = []\n    values.forEach((v) => {\n      list.push(encoder.encode(JSON.stringify(v)))\n    })\n    req.setInstancesList(list)\n    return this.unary(\n      API.Create,\n      req,\n      (res: pb.CreateReply) => res.toObject().instanceidsList,\n    )\n  }\n\n  /**\n   * Saves changes to an existing model instance in the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   * Each model instance must have a valid existing `_id` property.\n   *\n   * @example\n   * Update an existing instance\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function updateBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.length < 1) return\n   *\n   *   const buzz = result[0]\n   *   buzz.missions += 1\n   *\n   *   return await client.save(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public save(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[],\n  ): Promise<void> {\n    const req = new pb.SaveRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = []\n    values.forEach((v) => {\n      if (!v.hasOwnProperty('_id')) {\n        v['_id'] = '' // The server will add an _id if empty.\n      }\n      list.push(encoder.encode(JSON.stringify(v)))\n    })\n    req.setInstancesList(list)\n    return this.unary(API.Save, req)\n  }\n\n  /**\n   * Deletes an existing model instance from the given store.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param IDs An array of instance ids to delete.\n   *\n   * @example\n   * Delete any instances that return from a query\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function deleteBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.length < 1) return\n   *\n   *   const ids = await result.map((instance) => instance._id)\n   *   await client.delete(threadID, 'astronauts', ids)\n   * }\n   * ```\n   */\n  public delete(\n    threadID: ThreadID,\n    collectionName: string,\n    IDs: string[],\n  ): Promise<void> {\n    const req = new pb.DeleteRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceidsList(IDs)\n    return this.unary(API.Delete, req)\n  }\n\n  /**\n   * Check if a given instance exists in the collection.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param IDs An array of instance ids to check for.\n   *\n   * @example\n   * Check if an instance exists\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * async function instanceExists (client: Client, threadID: ThreadID, id: string) {\n   *   return await client.has(threadID, 'astronauts', [id])\n   * }\n   * ```\n   */\n  public has(\n    threadID: ThreadID,\n    collectionName: string,\n    IDs: string[],\n  ): Promise<boolean> {\n    const req = new pb.HasRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceidsList(IDs)\n    return this.unary(API.Has, req, (res: pb.HasReply) => res.getExists())\n  }\n\n  /**\n   * Queries a collection for entities matching the given query parameters.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param query The object that describes the query. User Query class or primitive QueryJSON type.\n   *\n   * @example\n   * Query with return type\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function getAstronautByName (client: Client, threadID: ThreadID, name: string) {\n   *   const query = new Where('name').eq(name)\n   *   const astronaut = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *   return astronaut\n   * }\n   * ```\n   */\n  public find<T = unknown>(\n    threadID: ThreadID,\n    collectionName: string,\n    query: QueryJSON,\n  ): Promise<T[]> {\n    const req = new pb.FindRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    // @todo: Find a more isomorphic way to do this base64 round-trip\n    req.setQueryjson(encoder.encode(JSON.stringify(query)))\n    return this.unary(API.Find, req, (res: pb.FindReply) => {\n      return res\n        .getInstancesList_asU8()\n        .map((instance) => JSON.parse(decoder.decode(instance)))\n    })\n  }\n\n  /**\n   * Queries the collection by a known instance ID.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param ID The id of the instance to search for.\n   *\n   * @example\n   * Find and cast a known model by instance ID.\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function getAstronaut (client: Client, threadID: ThreadID, id: string) {\n   *   const astronaut = await client.findByID<Astronaut>(threadID, 'astronauts', id)\n   *   return astronaut\n   * }\n   * ```\n   *\n   * @example\n   * Simple find and return any instance\n   * ```typescript\n   * import {Client, ThreadID} from '@textile/threads'\n   *\n   * async function getInstance (client: Client, threadID: ThreadID, id: string) {\n   *   return await client.findByID(threadID, 'astronauts', id)\n   * }\n   * ```\n   */\n  public findByID<T = unknown>(\n    threadID: ThreadID,\n    collectionName: string,\n    ID: string,\n  ): Promise<T> {\n    const req = new pb.FindByIDRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    req.setInstanceid(ID)\n    return this.unary(API.FindByID, req, (res: pb.FindByIDReply) =>\n      JSON.parse(decoder.decode(res.getInstance_asU8())),\n    )\n  }\n\n  /**\n   * Verify checks existing instance changes.\n   * Each model instance must have a valid existing `_id` property.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   * @param values An array of model instances as JSON/JS objects.\n   *\n   * @example\n   * Update an existing instance\n   * ```typescript\n   * import {Client, ThreadID, Where} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   *\n   * async function verifyBuzz (client: Client, threadID: ThreadID) {\n   *   const query = new Where('name').eq('Buzz')\n   *   const result = await client.find<Astronaut>(threadID, 'astronauts', query)\n   *\n   *   if (result.length < 1) return\n   *\n   *   const buzz = result[0]\n   *   buzz.missions += 1\n   *\n   *   // Is this going to be a valid update?\n   *   return await client.verify(threadID, 'astronauts', [buzz])\n   * }\n   * ```\n   */\n  public verify(\n    threadID: ThreadID,\n    collectionName: string,\n    values: any[],\n  ): Promise<void> {\n    const req = new pb.VerifyRequest()\n    req.setDbid(threadID.toBytes())\n    req.setCollectionname(collectionName)\n    const list: any[] = values.map((v) => encoder.encode(JSON.stringify(v)))\n    req.setInstancesList(list)\n    return this.unary(API.Verify, req)\n  }\n\n  /**\n   * readTransaction creates a new read-only transaction object. See ReadTransaction for details.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   */\n  public readTransaction(\n    threadID: ThreadID,\n    collectionName: string,\n  ): ReadTransaction {\n    // TODO: We can do this setup much cleaner!\n    const client: grpc.Client<\n      pb.ReadTransactionRequest,\n      pb.ReadTransactionReply\n    > = grpc.client(API.ReadTransaction, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    })\n    return new ReadTransaction(this.context, client, threadID, collectionName)\n  }\n\n  /**\n   * writeTransaction creates a new writeable transaction object. See WriteTransaction for details.\n   * @param threadID the ID of the database\n   * @param collectionName The human-readable name of the model to use.\n   */\n  public writeTransaction(\n    threadID: ThreadID,\n    collectionName: string,\n  ): WriteTransaction {\n    const client: grpc.Client<\n      pb.WriteTransactionRequest,\n      pb.WriteTransactionReply\n    > = grpc.client(API.WriteTransaction, {\n      host: this.serviceHost,\n      transport: this.rpcOptions.transport,\n      debug: this.rpcOptions.debug,\n    })\n    return new WriteTransaction(this.context, client, threadID, collectionName)\n  }\n\n  /**\n   * listen opens a long-lived connection with a remote node, running the given callback on each new update to the given instance.\n   * The return value is a `close` function, which cleanly closes the connection with the remote node.\n   * @param threadID the ID of the database\n   * @param filters contains an array of Filters\n   * @param callback The callback to call on each update to the given instance.\n   *\n   * @example\n   * ```typescript\n   * import {Client, ThreadID, Update} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   * function setupListener (client: Client, threadID: ThreadID) {\n   *   const callback = (update?: Update<Astronaut>) => {\n   *     // Not safe if more than the Astronauts collection existed in the same DB\n   *     if (!update || !update.instance) return\n   *     console.log('New update:', update.instance.name, update.instance.missions)\n   *   }\n   *   const closer = client.listen(threadID, [], callback)\n   *   return closer\n   * }\n   * ```\n   *\n   * @example\n   * Listen to only CREATE events on a specific Collection.\n   * ```typescript\n   * import {Client, ThreadID, Update} from '@textile/threads'\n   *\n   * interface Astronaut {\n   *   name: string\n   *   missions: number\n   *   _id: string\n   * }\n   * function setupListener (client: Client, threadID: ThreadID) {\n   *   const callback = (update?: Update<Astronaut>) => {\n   *     if (!update || !update.instance) return\n   *     console.log('New update:', update.instance.name, update.instance.missions)\n   *   }\n   *   const filters = [\n   *     {collectionName: 'Astronauts'},\n   *     {actionTypes: ['CREATE']}\n   *   ]\n   *   const closer = client.listen(threadID, filters, callback)\n   *   return closer\n   * }\n   * ```\n   */\n  public listen<T = any>(\n    threadID: ThreadID,\n    filters: Filter[],\n    callback: (reply?: Update<T>, err?: Error) => void,\n  ): grpc.Request {\n    const req = new pb.ListenRequest()\n    req.setDbid(threadID.toBytes())\n    for (const filter of filters) {\n      const requestFilter = new pb.ListenRequest.Filter()\n      if (filter.instanceID) {\n        requestFilter.setInstanceid(filter.instanceID)\n      } else if (filter.collectionName) {\n        requestFilter.setCollectionname(filter.collectionName)\n      }\n      if (filter.actionTypes) {\n        for (const at of filter.actionTypes) {\n          switch (at) {\n            case 'ALL': {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.ALL)\n              break\n            }\n            case 'CREATE': {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.CREATE)\n              break\n            }\n            case 'SAVE': {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.SAVE)\n              break\n            }\n            case 'DELETE': {\n              requestFilter.setAction(pb.ListenRequest.Filter.Action.DELETE)\n              break\n            }\n          }\n        }\n      } else {\n        requestFilter.setAction(0)\n      }\n      req.addFilters(requestFilter)\n    }\n\n    const decoder = new TextDecoder()\n\n    const client = grpc.client<pb.ListenRequest, pb.ListenReply, APIListen>(\n      API.Listen,\n      {\n        host: this.serviceHost,\n        transport: this.rpcOptions.transport,\n        debug: this.rpcOptions.debug,\n      },\n    )\n    client.onMessage((message: pb.ListenReply) => {\n      // Pull it apart explicitly\n      const instanceString = decoder.decode(message.getInstance_asU8())\n      const actionInt = message.getAction()\n      const action = (Action[actionInt] as unknown) as Action\n      const collectionName = message.getCollectionname()\n      const instanceID = message.getInstanceid()\n\n      const ret: Update<T> = {\n        collectionName,\n        instanceID,\n        action,\n        instance: undefined,\n      }\n      if (instanceString !== '') {\n        ret.instance = JSON.parse(instanceString)\n      }\n      callback(ret)\n    })\n\n    client.onEnd((\n      status: grpc.Code,\n      message: string /** trailers: grpc.Metadata */,\n    ) => {\n      if (status !== grpc.Code.OK) {\n        callback(undefined, new Error(message))\n      }\n      callback()\n    })\n\n    this.context.toMetadata().then((metadata) => {\n      client.start(metadata)\n      client.send(req)\n      client.finishSend()\n    })\n    return { close: () => client.close() }\n  }\n\n  private async unary<\n    TResponse extends grpc.ProtobufMessage,\n    TRequest extends grpc.ProtobufMessage,\n    M extends grpc.UnaryMethodDefinition<TRequest, TResponse>,\n    O = undefined // Only thing we can't know ahead of time\n  >(\n    methodDescriptor: M,\n    req: TRequest,\n    mapper: (resp: TResponse) => O | undefined = () => undefined,\n  ) {\n    const metadata = await this.context.toMetadata()\n    return new Promise<O>((resolve, reject) => {\n      grpc.unary(methodDescriptor, {\n        transport: this.rpcOptions.transport,\n        debug: this.rpcOptions.debug,\n        request: req,\n        host: this.serviceHost,\n        metadata,\n        onEnd: (res: UnaryOutput<TResponse>) => {\n          const { status, statusMessage, message } = res\n          if (status === grpc.Code.OK) {\n            resolve(mapper(message as any) as O)\n          } else {\n            reject(new Error(statusMessage))\n          }\n        },\n      })\n    })\n  }\n}\n\nexport default Client\n"]}