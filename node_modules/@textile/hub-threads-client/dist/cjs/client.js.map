{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"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","sourcesContent":["import { Context } from '@textile/context'\nimport { ServiceError } from '@textile/hub-grpc/api/hubd/pb/hubd_pb_service'\nimport { KeyInfo, UserAuth } from '@textile/security'\nimport { Client } from '@textile/threads-client'\nimport { ThreadID } from '@textile/threads-id'\nimport {\n  GetThreadRequest,\n  GetThreadResponse as _GetThreadResponse,\n  ListThreadsRequest,\n  ListThreadsResponse as _ListThreadsResponse,\n} from '@textile/users-grpc/api/usersd/pb/usersd_pb'\nimport { APIServiceClient } from '@textile/users-grpc/api/usersd/pb/usersd_pb_service'\nimport log from 'loglevel'\n\nconst logger = log.getLogger('users')\n\ninterface GetThreadResponse {\n  id: string\n  name?: string\n}\n\ndeclare module '@textile/threads-client' {\n  interface Client {\n    getThread(name: string, ctx?: Context): Promise<GetThreadResponse>\n    listThreads(ctx?: Context): Promise<Array<GetThreadResponse>>\n  }\n}\n\nClient.prototype.getThread = async function (\n  name: string,\n  ctx?: Context,\n): Promise<GetThreadResponse> {\n  logger.debug('get thread request')\n  const client = new APIServiceClient(this.serviceHost, {\n    transport: this.rpcOptions.transport,\n    debug: this.rpcOptions.debug,\n  })\n  return new Promise<GetThreadResponse>((resolve, reject) => {\n    const req = new GetThreadRequest()\n    req.setName(name)\n    this.context\n      .toMetadata(ctx)\n      .then((meta) => {\n        client.getThread(\n          req,\n          meta,\n          (err: ServiceError | null, message: _GetThreadResponse | null) => {\n            if (err) reject(err)\n            if (message) {\n              const res = {\n                name: message.getName(),\n                id: ThreadID.fromBytes(message.getId_asU8()).toString(),\n              }\n              resolve(res)\n            } else {\n              reject(new Error('No result'))\n            }\n          },\n        )\n      })\n      .catch((err: Error) => {\n        reject(err)\n      })\n  })\n}\n\n// Private listDBs method\nconst oldListDBs = Client.prototype.listDBs\n\n/**\n * Lists all known DBs.\n */\nClient.prototype.listDBs = async function (\n  ctx?: Context,\n): Promise<Array<GetThreadResponse>> {\n  if (this.context.withContext(ctx).get('x-textile-api-sig')) {\n    // We're probably on the Hub\n    return this.listThreads(ctx)\n  }\n  return oldListDBs\n    .bind(this)()\n    .catch((err) => {\n      if (err.message.includes('Method is not accessible')) {\n        // We might be unauthenticated _or_ not on hub.\n        throw new Error(\n          `${err.message}. If using Hub, ensure you are using a valid API signature.`,\n        )\n      }\n      throw err\n    })\n}\n\n/**\n * Returns a list of available Threads.\n * @param ctx Context containing gRPC headers and settings.\n * These will be merged with any internal credentials.\n * @note Threads can be created using the threads or threads network clients.\n */\nClient.prototype.listThreads = async function (\n  ctx?: Context,\n): Promise<Array<GetThreadResponse>> {\n  logger.debug('list threads request')\n  const client = new APIServiceClient(this.serviceHost, {\n    transport: this.rpcOptions.transport,\n    debug: this.rpcOptions.debug,\n  })\n  return new Promise<Array<GetThreadResponse>>((resolve, reject) => {\n    const req = new ListThreadsRequest()\n    this.context\n      .toMetadata(ctx)\n      .then((meta) => {\n        client.listThreads(\n          req,\n          meta,\n          (err: ServiceError | null, message: _ListThreadsResponse | null) => {\n            if (err) return reject(err)\n            const lst = message?.getListList()\n            let results: GetThreadResponse[] = []\n            if (!lst) return resolve(results)\n            results = lst.map((thrd: _GetThreadResponse) => {\n              return {\n                name: thrd.getName(),\n                id: ThreadID.fromBytes(thrd.getId_asU8()).toString(),\n              }\n            })\n            return resolve(results)\n          },\n        )\n      })\n      .catch((err: Error) => {\n        return reject(err)\n      })\n  })\n}\n\n/**\n * Clients is a web-gRPC wrapper client for communicating with the web-gRPC enabled Threads API.\n */\nexport { Client, GetThreadResponse, KeyInfo, UserAuth }\n"]}