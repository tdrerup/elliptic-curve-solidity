{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { GrpcConnection } from '@textile/grpc-connection'\nimport { bucketsListPath, CHUNK_SIZE } from './api'\nimport { Path, PathItem } from './types'\n\n/**\n * bytesToArray converts a buffer into <4mb chunks for use with grpc API\n * @param chunk an input Buffer or Uint8Array\n */\nexport function bytesToArray(\n  chunk: Uint8Array,\n  size = CHUNK_SIZE * CHUNK_SIZE * 3,\n): Uint8Array[] {\n  const result = []\n  const len = chunk.length\n  let i = 0\n  while (i < len) {\n    result.push(chunk.slice(i, (i += size)))\n  }\n  return result\n}\n\n/**\n * listPathRecursive returns a nested object of all paths (and info) in a bucket\n */\nexport async function listPathRecursive(\n  grpc: GrpcConnection,\n  bucketKey: string,\n  path: string,\n  depth: number,\n  currentDepth = 0,\n): Promise<Path> {\n  const rootPath = path === '' || path === '.' || path === '/' ? '' : `${path}/`\n  const tree = await bucketsListPath(grpc, bucketKey, path)\n  if (tree.item && (currentDepth + 1 <= depth || depth === -1)) {\n    for (let i = 0; i < tree.item.items.length; i++) {\n      const obj = tree.item.items[i]\n      if (!obj.isDir) continue\n      const dirPath = `${rootPath}${obj.name}`\n      const { item } = await listPathRecursive(\n        grpc,\n        bucketKey,\n        dirPath,\n        depth,\n        currentDepth + 1,\n      )\n      if (item) {\n        tree.item.items[i] = item\n      }\n    }\n  }\n  return tree\n}\n\nasync function treeToPaths(\n  tree: PathItem[],\n  path?: string,\n  dirs = true,\n  depth = 5,\n  currentDepth = 0,\n): Promise<Array<string>> {\n  const result = []\n  for (const item of tree) {\n    const newPath = path === '' ? `${item.name}` : `${path}/${item.name}`\n    if (dirs || !item.isDir) result.push(newPath)\n    if (item.isDir && (currentDepth < depth || depth === -1)) {\n      const downtree = await treeToPaths(\n        item.items,\n        newPath,\n        dirs,\n        depth,\n        currentDepth + 1,\n      )\n      result.push(...downtree)\n    }\n  }\n  return result\n}\n\n/**\n * listPathFlat returns a string array of all paths in a bucket\n */\nexport async function listPathFlat(\n  grpc: GrpcConnection,\n  bucketKey: string,\n  path: string,\n  dirs: boolean,\n  depth: number,\n): Promise<Array<string>> {\n  const tree = await listPathRecursive(grpc, bucketKey, path, depth)\n  if (!tree.item) return []\n  return treeToPaths(tree.item.items, path, dirs)\n}\n"]}