{"version":3,"file":"buckets.js","sourceRoot":"","sources":["../../src/buckets.ts"],"names":[],"mappings":"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","sourcesContent":["import { Identity } from '@textile/crypto'\nimport {\n  CopyAuthOptions,\n  GrpcAuthentication,\n  WithKeyInfoOptions,\n  WithUserAuthOptions,\n} from '@textile/grpc-authentication'\nimport { Client } from '@textile/hub-threads-client'\nimport { KeyInfo, UserAuth } from '@textile/security'\nimport { ThreadID } from '@textile/threads-id'\nimport log from 'loglevel'\nimport {\n  bucketsArchive,\n  bucketsArchives,\n  bucketsArchiveWatch,\n  bucketsCreate,\n  bucketsDefaultArchiveConfig,\n  bucketsLinks,\n  bucketsList,\n  bucketsListIpfsPath,\n  bucketsMovePath,\n  bucketsPullIpfsPath,\n  bucketsPullPath,\n  bucketsPullPathAccessRoles,\n  bucketsPushPath,\n  bucketsPushPathAccessRoles,\n  bucketsPushPaths,\n  bucketsRemove,\n  bucketsRemovePath,\n  bucketsRoot,\n  bucketsSetDefaultArchiveConfig,\n  bucketsSetPath,\n  CHUNK_SIZE,\n} from './api'\nimport {\n  ArchiveConfig,\n  ArchiveOptions,\n  Archives,\n  CreateOptions,\n  CreateResponse,\n  GetOrCreateOptions,\n  GetOrCreateResponse,\n  Links,\n  Path,\n  PathAccessRole,\n  PathItem,\n  PushOptions,\n  PushPathResult,\n  PushPathsResult,\n  RemovePathOptions,\n  RemovePathResponse,\n  Root,\n} from './types'\nimport { listPathFlat, listPathRecursive } from './utils'\n\nconst logger = log.getLogger('buckets')\n\n/**\n * Buckets a client wrapper for interacting with the Textile Buckets API.\n * @example\n * Initialize the Bucket API and open an existing bucket (or create if new).\n * ```typescript\n * import { Buckets, UserAuth } from '@textile/hub'\n *\n * const getOrCreate = async (auth: UserAuth, bucketName: string) => {\n *   const buckets = Buckets.withUserAuth(auth)\n *   // Automatically scopes future calls on `buckets` to the Thread containing the bucket\n *   const { root, threadID } = await buckets.getOrCreate(bucketName)\n *   if (!root) throw new Error('bucket not created')\n *   const bucketKey = root.key\n *   return { buckets, bucketKey }\n * }\n * ```\n *\n * @example\n * Print the links for the bucket\n * ```typescript\n * import { Buckets } from '@textile/hub'\n *\n * // This method requires that you run \"getOrCreate\" or have specified \"withThread\"\n * async function logLinks (buckets: Buckets, bucketKey: string) {\n *   const links = await buckets.links(bucketKey)\n *   console.log(links)\n * }\n * ```\n *\n * @example\n * Find an existing Bucket\n * ```typescript\n * import { Buckets } from '@textile/hub'\n *\n * // This method requires that you already specify the Thread containing\n * // the bucket with buckets.withThread(<thread name>).\n * const exists = async (buckets: Buckets, bucketName: string) => {\n *     const roots = await buckets.list();\n *     return roots.find((bucket) => bucket.name === bucketName)\n * }\n * ```\n *\n * @example\n * Push an folder in node.js\n * ```typescript\n * import fs from 'fs'\n * import util from 'util'\n * import glob from 'glob'\n * import { Buckets } from '@textile/hub'\n *\n * const globDir = util.promisify(glob)\n *\n * // expects an already setup buckets session using getOrCreate or withThread\n * const exists = async (buckets: Buckets, bucketKey: string, dir: string) => {\n *   const files = await globDir('<dir glob options>')\n *   return await Promise.all(files.map(async (file) => {\n *     const filePath = dir + '/' + file\n *     var content = fs.createReadStream(filePath, { highWaterMark: 1024 * 1024 * 3 });\n *     const upload = {\n *       path: file,\n *       content\n *     }\n *     return await buckets.pushPath(bucketKey, file, upload)\n *   }))\n * }\n * ```\n */\nexport class Buckets extends GrpcAuthentication {\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.copyAuth}\n   *\n   * @example\n   * Copy an authenticated Users api instance to Buckets.\n   * ```typescript\n   * import { Buckets, Users } from '@textile/hub'\n   *\n   * const usersToBuckets = async (user: Users) => {\n   *   const buckets = Buckets.copyAuth(user)\n   *   return buckets\n   * }\n   * ```\n   *\n   * @example\n   * Copy an authenticated Buckets api instance to Users.\n   * ```typescript\n   * import { Buckets, Users } from '@textile/hub'\n   *\n   * const bucketsToUsers = async (buckets: Buckets) => {\n   *   const user = Users.copyAuth(buckets)\n   *   return user\n   * }\n   * ```\n   */\n  static copyAuth(\n    auth: GrpcAuthentication,\n    options?: CopyAuthOptions,\n  ): Buckets {\n    return new Buckets(auth.context, options?.debug)\n  }\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.withUserAuth}\n   *\n   * @example\n   * ```@typescript\n   * import { Buckets, UserAuth } from '@textile/hub'\n   *\n   * async function example (userAuth: UserAuth) {\n   *   const buckets = await Buckets.withUserAuth(userAuth)\n   * }\n   * ```\n   */\n  static withUserAuth(\n    auth: UserAuth | (() => Promise<UserAuth>),\n    options?: WithUserAuthOptions,\n  ): Buckets {\n    const res = super.withUserAuth(auth, options)\n    return this.copyAuth(res, options)\n  }\n\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.withKeyInfo}\n   *\n   * @example\n   * ```@typescript\n   * import { Buckets, KeyInfo } from '@textile/hub'\n   *\n   * async function start () {\n   *   const keyInfo: KeyInfo = {\n   *     key: '<api key>',\n   *     secret: '<api secret>'\n   *   }\n   *   const buckets = await Buckets.withKeyInfo(keyInfo)\n   * }\n   * ```\n   */\n  static async withKeyInfo(\n    key: KeyInfo,\n    options?: WithKeyInfoOptions,\n  ): Promise<Buckets> {\n    const auth = await super.withKeyInfo(key, options)\n    return this.copyAuth(auth, options)\n  }\n\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.withThread}\n   *\n   * @example\n   * ```@typescript\n   * import { Buckets, ThreadID } from '@textile/hub'\n   *\n   * async function example (threadID: ThreadID) {\n   *   const id = threadID.toString()\n   *   const buckets = await Buckets.withThread(id)\n   * }\n   * ```\n   */\n  withThread(threadID?: string): void {\n    return super.withThread(threadID)\n  }\n\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.getToken}\n   *\n   * @example\n   * ```@typescript\n   * import { Buckets, PrivateKey } from '@textile/hub'\n   *\n   * async function example (buckets: Buckets, identity: PrivateKey) {\n   *   const token = await buckets.getToken(identity)\n   *   return token // already added to `buckets` scope\n   * }\n   * ```\n   */\n  async getToken(identity: Identity): Promise<string> {\n    return super.getToken(identity)\n  }\n\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.getToken}\n   */\n  setToken(token: string): Promise<void> {\n    return super.setToken(token)\n  }\n\n  /**\n   * {@inheritDoc @textile/hub#GrpcAuthentication.getTokenChallenge}\n   *\n   * @example\n   * ```typescript\n   * import { Buckets, PrivateKey } from '@textile/hub'\n   *\n   * async function example (buckets: Buckets, identity: PrivateKey) {\n   *   const token = await buckets.getTokenChallenge(\n   *     identity.public.toString(),\n   *     (challenge: Uint8Array) => {\n   *       return new Promise((resolve, reject) => {\n   *         // This is where you should program PrivateKey to respond to challenge\n   *         // Read more here: https://docs.textile.io/tutorials/hub/production-auth/\n   *       })\n   *     }\n   *   )\n   *   return token\n   * }\n   * ```\n   */\n  async getTokenChallenge(\n    publicKey: string,\n    callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>,\n  ): Promise<string> {\n    return super.getTokenChallenge(publicKey, callback)\n  }\n\n  /**\n   * (Deprecated) Open a new / existing bucket by bucket name and ThreadID (create not required)\n   * @param name name of bucket\n   * @param threadName the name of the thread where the bucket is stored (default `buckets`)\n   * @param encrypted encrypt the bucket contents (default `false`)\n   * @param threadID id of thread where bucket is stored\n   * @deprecated Open has been replaced with getOrCreate\n   */\n  async open(\n    name: string,\n    threadName = 'buckets',\n    encrypted = false,\n    threadID?: string,\n  ): Promise<{ root?: Root; threadID?: string }> {\n    const options: GetOrCreateOptions = {\n      threadName: threadName && threadName !== '' ? threadName : 'buckets',\n      encrypted: !!encrypted,\n      threadID,\n    }\n    return this.getOrCreate(name, options)\n  }\n\n  /**\n   * (Deprecated) Open a new / existing bucket by bucket name and ThreadID (create not required)\n   * @param name name of bucket\n   * @param threadName the name of the thread where the bucket is stored (default `buckets`)\n   * @param encrypted encrypt the bucket contents (default `false`)\n   * @param threadID id of thread where bucket is stored\n   * @deprecated getOrInit has been replaced with getOrCreate\n   */\n  async getOrInit(\n    name: string,\n    threadName = 'buckets',\n    encrypted = false,\n    threadID?: string,\n  ): Promise<{ root?: Root; threadID?: string }> {\n    const options: GetOrCreateOptions = {\n      threadName: threadName && threadName !== '' ? threadName : 'buckets',\n      encrypted: !!encrypted,\n      threadID,\n    }\n    return this.getOrCreate(name, options)\n  }\n\n  /**\n   * Open a new / existing bucket by bucket name and ThreadID (create not required)\n   * Replaces `open` command in older versions.\n   * @param name name of bucket\n   * @param threadName (optional) the name of the thread where the bucket is stored (default `buckets`)\n   * @param encrypted (optional) encrypt the bucket contents (default `false`)\n   * @param cid (optional) Bootstrap the bucket with a UnixFS Cid from the IPFS network\n   * @param threadID (optional) id of thread where bucket is stored\n   *\n   * @remarks\n   * The IPFS protocol and its implementations are still in heavy\n   * development. By using Textile, you are acknowledging that you\n   * understand there may be risks to storing your content on or\n   * using decentralized storage services.\n   *\n   * @example\n   * Create a Bucket called \"app-name-files\"\n   * ```typescript\n   * import { Buckets, UserAuth } from '@textile/hub'\n   *\n   * const open = async (auth: UserAuth, name: string) => {\n   *     const buckets = Buckets.withUserAuth(auth)\n   *     const { root, threadID } = await buckets.getOrCreate(name)\n   *     return { buckets, root, threadID }\n   * }\n   * ```\n   */\n  async getOrCreate(\n    name: string,\n    options?: GetOrCreateOptions,\n  ): Promise<GetOrCreateResponse>\n  async getOrCreate(\n    name: string,\n    options?: string | GetOrCreateOptions,\n    encrypted?: boolean,\n    cid?: string,\n    threadID?: string,\n  ): Promise<{ root?: Root; threadID?: string }> {\n    if (!options && (encrypted || cid || threadID)) {\n      // Case where threadName passed as undefined using old signature\n      console.warn(\n        'Update Buckets.getOrCreate to use GetOrCreateOptions input.',\n      )\n      return this._getOrCreate(name, 'buckets', !!encrypted, cid, threadID)\n    } else if (!options) {\n      return this._getOrCreate(name)\n    } else if (typeof options !== 'object') {\n      // Case where using old signature\n      console.warn(\n        'Update Buckets.getOrCreate to use GetOrCreateOptions input.',\n      )\n      return this._getOrCreate(name, options, !!encrypted, cid, threadID)\n    } else {\n      // Using new signature\n      const threadName =\n        options.threadName && options.threadName !== ''\n          ? options.threadName\n          : 'buckets'\n      const encrypted = !!options.encrypted\n      return this._getOrCreate(\n        name,\n        threadName,\n        encrypted,\n        options.cid,\n        options.threadID,\n      )\n    }\n  }\n  /**\n   * @internal\n   */\n  private async _getOrCreate(\n    name: string,\n    threadName = 'buckets',\n    encrypted = false,\n    cid?: string,\n    threadID?: string,\n  ): Promise<{ root?: Root; threadID?: string }> {\n    const client = new Client(this.context)\n    if (threadID) {\n      const id = threadID\n      const res = await client.listThreads()\n      const exists = res.find((thread: any) => thread.id === id)\n      if (!exists) {\n        const id = ThreadID.fromString(threadID)\n        await client.newDB(id, threadName)\n      }\n      this.withThread(threadID)\n    } else {\n      try {\n        const res = await client.getThread(threadName)\n        threadID =\n          typeof res.id === 'string'\n            ? res.id\n            : ThreadID.fromBytes(res.id).toString()\n        this.withThread(threadID)\n      } catch (error) {\n        if (\n          error.message !== 'Thread not found' &&\n          !error.message.includes('mongo: no documents in result')\n        ) {\n          throw new Error(error.message)\n        }\n        const newId = ThreadID.fromRandom()\n        await client.newDB(newId, threadName)\n        threadID = newId.toString()\n        this.withThread(threadID)\n      }\n    }\n\n    const roots = await this.list()\n    const existing = roots.find((bucket) => bucket.name === name)\n    if (existing) {\n      return { root: existing, threadID }\n    }\n    const created = await this.create(name, { encrypted, cid })\n    return { root: created.root, threadID }\n  }\n\n  /**\n   * Existing lists all remote buckets in the thread or in all threads.\n   * @param threadID (optional) if threadID is not defined, this will return buckets from all threads.\n   */\n  async existing(threadID?: string): Promise<Root[]> {\n    const client = new Client(this.context)\n    const threads = []\n\n    if (threadID) {\n      threads.push(threadID)\n    } else {\n      const res = await client.listThreads()\n      for (const thread of res) {\n        if (thread.id) threads.push(thread.id)\n      }\n    }\n\n    const bucketList: Root[] = []\n    for (const id of threads) {\n      this.withThread(id)\n      for (const root of await this.list()) {\n        bucketList.push(root)\n      }\n    }\n    // Clear the currently used thread\n    this.withThread(undefined)\n\n    return bucketList\n  }\n\n  /**\n   * (Deprecated) Creates a new bucket.\n   * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.\n   * @param encrypted encrypt the bucket contents (default `false`)\n   * @deprecated Init has been replaced by create\n   */\n  async init(name: string, encrypted = false): Promise<CreateResponse> {\n    return this.create(name, { encrypted })\n  }\n\n  /**\n   * Creates a new bucket.\n   * @public\n   * @param name Human-readable bucket name. It is only meant to help identify a bucket in a UI and is not unique.\n   * @param encrypted encrypt the bucket contents (default `false`)\n   * @param cid (optional) Bootstrap the bucket with a UnixFS Cid from the IPFS network\n   * @example\n   * Create a Bucket called \"app-name-files\"\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const create = async (buckets: Buckets) => {\n   *     return buckets.create(\"app-name-files\")\n   * }\n   * ```\n   */\n  async create(name: string, options?: CreateOptions): Promise<CreateResponse>\n  async create(\n    name: string,\n    options?: boolean | CreateOptions,\n    cid?: string,\n  ): Promise<CreateResponse> {\n    logger.debug('create request')\n    if (typeof options == 'object') {\n      return bucketsCreate(this, name, !!options.encrypted, options.cid)\n    } else {\n      if (options !== undefined || cid !== undefined) {\n        console.warn('Update Buckets.create to use CreateOptions input.')\n      }\n      const encrypted = !!options\n      return bucketsCreate(this, name, encrypted, cid)\n    }\n  }\n\n  /**\n   * Returns the bucket root CID\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   */\n  async root(key: string): Promise<Root | undefined> {\n    logger.debug('root request')\n    return bucketsRoot(this, key)\n  }\n\n  /**\n   * Returns a list of bucket links.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path path within the bucket for links (default '/').\n   * @example\n   * Generate the HTTP, IPNS, and IPFS links for a Bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const getIpnsLink = async (buckets: Buckets, bucketKey: string) => {\n   *    const links = await buckets.links(bucketKey)\n   *    return links.ipns\n   * }\n   *\n   * const getWwwLink = async (buckets: Buckets, bucketKey: string) => {\n   *    const links = await buckets.links(bucketKey)\n   *    return links.www\n   * }\n   * ```\n   */\n  async links(key: string, path = '/'): Promise<Links> {\n    logger.debug('link request')\n    return bucketsLinks(this, key, path)\n  }\n\n  /**\n   * Returns a list of all bucket roots.\n   * @example\n   * Find an existing Bucket named \"app-name-files\"\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const exists = async (buckets: Buckets) => {\n   *     const roots = await buckets.list();\n   *     return roots.find((bucket) => bucket.name ===  \"app-name-files\")\n   * }\n   * ````\n   */\n  async list(): Promise<Root[]> {\n    logger.debug('list request')\n    return bucketsList(this)\n  }\n\n  /**\n   * Returns information about a bucket path.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param depth (optional) will walk the entire bucket to target depth (default = 1)\n   */\n  async listPath(key: string, path: string, depth = 1): Promise<Path> {\n    logger.debug('list path request')\n    return await listPathRecursive(this, key, path, depth)\n  }\n\n  /**\n   * listPathRecursive returns a nested object of all paths (and info) in a bucket\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param dirs (optional) if false will include only file paths\n   * @param depth (optional) will walk the entire bucket to target depth (default = 1)\n   *\n   * @example\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function printPaths(buckets: Buckets, bucketKey: string) {\n   *   const list = await buckets.listPathFlat(bucketKey, '')\n   *   console.log(list)\n   * }\n   * // [\n   * //   '.textileseed',\n   * //   'dir1',\n   * //   'dir1/file1.jpg',\n   * //   'path',\n   * //   'path/to',\n   * //   'path/to/file2.jpg'\n   * // ]\n   * ```\n   */\n  async listPathFlat(\n    key: string,\n    path: string,\n    dirs = true,\n    depth = 5,\n  ): Promise<Array<string>> {\n    logger.debug('list path recursive request')\n    return await listPathFlat(this, key, path, dirs, depth)\n  }\n\n  /**\n   * listIpfsPath returns items at a particular path in a UnixFS path living in the IPFS network.\n   * @param path UnixFS path\n   */\n  async listIpfsPath(path: string): Promise<PathItem | undefined> {\n    logger.debug('list path request')\n    return bucketsListIpfsPath(this, path)\n  }\n\n  /**\n   * Move a file or subpath to a new path.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param fromPath A file/object or subpath within a bucket.\n   * @param toPath The path within a bucket to move fromPath to.\n   *\n   * @example\n   * Push a file to the root of a bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const moveToRoot = async (buckets: Buckets, key: string, fromPath: string) => {\n   *    return await buckets.movePath(key, fromPath, \"\")\n   * }\n   * ```\n   */\n  async movePath(key: string, fromPath: string, toPath: string): Promise<void> {\n    return bucketsMovePath(this, key, fromPath, toPath)\n  }\n\n  /**\n   * Pushes a file to a bucket path.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param input The input file/stream/object.\n   * @param opts Options to control response stream.\n   * @remarks\n   * - This will return the resolved path and the bucket's new root path.\n   * - If pushing NodeJS streams, ensure you set your highwatermark to an appropriate size\n   * (i.e., ~1024 bytes) for optimal behavior on slow or intermittent connections. See example\n   * below or use `utils.createReadStream`.\n   * @example\n   * Push a file to the root of a bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const pushFile = async (buckets: Buckets, content: string, bucketKey: string) => {\n   *    const file = { path: '/index.html', content: Buffer.from(content) }\n   *    return await buckets.pushPath(bucketKey!, 'index.html', file)\n   * }\n   * ```\n   *\n   * @example\n   * Push an folder in node.js\n   * ```typescript\n   * import fs from 'fs'\n   * import util from 'util'\n   * import glob from 'glob'\n   * import { Buckets } from '@textile/hub'\n   *\n   * const globDir = util.promisify(glob)\n   *\n   * // expects an already setup buckets session using getOrCreate or withThread\n   * const exists = async (buckets: Buckets, bucketKey: string, dir: string) => {\n   *   const files = await globDir('<dir glob options>')\n   *   return await Promise.all(files.map(async (file) => {\n   *     const filePath = dir + '/' + file\n   *     var content = fs.createReadStream(filePath, { highWaterMark: 1024 });\n   *     const upload = {\n   *       path: file,\n   *       content\n   *     }\n   *     return await buckets.pushPath(bucketKey, file, upload)\n   *   }))\n   * }\n   * ```\n   */\n  async pushPath(\n    key: string,\n    path: string,\n    input: any,\n    options?: PushOptions,\n  ): Promise<PushPathResult> {\n    return bucketsPushPath(this, key, path, input, options)\n  }\n\n  /**\n   * Pushes an iterable of files to a bucket.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param input The input array of file/stream/objects.\n   * @param options PushOptions to control response stream.\n   * @example\n   * Push all files in a directory to the root of a bucket\n   * ```typescript\n   * import fs from 'fs'\n   * import path from 'path'\n   * import util from 'util'\n   * import glob from 'glob'\n   * import { Buckets } from '@textile/hub'\n   *\n   * const globDir = util.promisify(glob)\n   * \n   * const pushMultipleFiles = async (buckets: Buckets, bucketKey: string, directory: string, globPattern: string) => {\n   *   const options = {\n   *     directory,\n   *     nodir: true,\n   *   }\n   *   const files = await globDir(globPattern, options)\n   *   if (files.length === 0) {\n   *     throw Error(`No files found: ${directory}`)\n   *   }\n   * \n   *   let streams = []\n   *   for (const file of files) {\n   *       const stream = fs.createReadStream(\n   *         path.join(directory, file), {\n   *           highWaterMark: 1024,\n   *         }\n   *       )\n   *       streams.push({\n   *         path: file,\n   *         content: stream,\n   *       })\n   *   }\n   *   return await buckets.pushPaths(bucketKey, streams)\n   * }\n   * ```\n   */\n  pushPaths(\n    key: string,\n    input: any,\n    options?: PushOptions,\n  ): AsyncIterableIterator<PushPathsResult> {\n    return bucketsPushPaths(this, key, input, options)\n  }\n\n  /**\n   * Pulls the bucket path, returning the bytes of the given file.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param opts Options to control response stream. Currently only supports a progress function.\n   *\n   * @example\n   * Pull a file by its relative path and console.log the progress.\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const pullFile = async (buckets: Buckets, key: string, path: string) => {\n   *    const display = (num?: number) => {\n   *      console.log('Progress:', num)\n   *    }\n   *    buckets.pullPath(key, path, {progress: display})\n   * }\n   * ```\n   */\n  pullPath(\n    key: string,\n    path: string,\n    options?: { progress?: (num?: number) => void },\n  ): AsyncIterableIterator<Uint8Array> {\n    return bucketsPullPath(this, key, path, options)\n  }\n\n  /**\n   * Pushes a file to a bucket path.\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param cid The IPFS cid of the dag to set at the path.\n   *\n   * @example\n   * Push a file to the root of a bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const pushRoot = async (buckets: Buckets, key: string, cid: string) => {\n   *    return await buckets.setPath(key, '/', cid)\n   * }\n   * ```\n   */\n  async setPath(key: string, path: string, cid: string): Promise<void> {\n    return bucketsSetPath(this, key, path, cid)\n  }\n\n  /**\n   * pullIpfsPath pulls the path from a remote UnixFS dag, writing it to writer if it's a file.\n   * @param path A file/object (sub)-path within a bucket.\n   * @param opts Options to control response stream. Currently only supports a progress function.\n   *\n   * @example\n   * Pull a file by its IPFS path and console.log the progress.\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const pullFile = async (buckets: Buckets, path: string) => {\n   *    const display = (num?: number) => {\n   *      console.log('Progress:', num)\n   *    }\n   *    buckets.pullIpfsPath(path, {progress: display})\n   * }\n   * ```\n   */\n  pullIpfsPath(\n    path: string,\n    options?: { progress?: (num?: number) => void },\n  ): AsyncIterableIterator<Uint8Array> {\n    return bucketsPullIpfsPath(this, path, options)\n  }\n\n  /**\n   * Removes an entire bucket. Files and directories will be unpinned (cannot be undone).\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   *\n   * @example\n   * Remove a Bucket\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const remove = async (buckets: Buckets, key: string) => {\n   *    buckets.remove(key)\n   * }\n   * ```\n   */\n  async remove(key: string): Promise<void> {\n    logger.debug('remove request')\n    return bucketsRemove(this, key)\n  }\n\n  /**\n   * Returns information about a bucket path (cannot be undone).\n   *\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A relative path within a bucket.\n   * @param root optional to specify a root.\n   *\n   * @example\n   * Remove a file by its relative path\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const remove = async (buckets: Buckets, key: string) => {\n   *    buckets.remove(key)\n   * }\n   * ```\n   */\n  async removePath(\n    key: string,\n    path: string,\n    options?: RemovePathOptions,\n  ): Promise<RemovePathResponse> {\n    logger.debug('remove path request')\n    return bucketsRemovePath(this, key, path, options)\n  }\n\n  /**\n   * Push new access roles per path in a Bucket\n   *\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A relative path within a bucket.\n   * @param roles Each user public key and the roles they will receive.\n   *\n   * @example\n   * ```typescript\n   * import { Buckets, PublicKey } from '@textile/hub'\n   *\n   * const grant = async (buckets: Buckets, key: string, peer: PublicKey) => {\n   *    const roles = new Map()\n   *    // NA = 0, Reader = 1, Writer = 2, Admin = 3\n   *    roles.set(peer.toString(), 2)\n   *    buckets.pushPathAccessRoles(key, '/', roles)\n   * }\n   * ```\n   * @example\n   * Grant read access to everyone at a path (in an encrypted bucket)\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const grant = async (buckets: Buckets, key: string) => {\n   *    const roles = new Map()\n   *    // NA = 0, Reader = 1, Writer = 2, Admin = 3\n   *    roles.set('*', 1)\n   *    buckets.pushPathAccessRoles(key, '/folder/containing/shared/things', roles)\n   * }\n   * ```\n   */\n  async pushPathAccessRoles(\n    key: string,\n    path: string,\n    roles: Map<string, PathAccessRole>,\n  ): Promise<void> {\n    logger.debug('push path access roles request')\n    return bucketsPushPathAccessRoles(this, key, path, roles)\n  }\n\n  /**\n   * List the access roles per path in a Bucket\n   *\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param path A relative path within a bucket.\n   *\n   * @example\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * const viewRoot = async (buckets: Buckets, key: string) => {\n   *    const list = buckets.pullPathAccessRoles(key, '/')\n   *    console.log(list)\n   * }\n   * ```\n   */\n  async pullPathAccessRoles(\n    key: string,\n    path?: string,\n  ): Promise<Map<string, 0 | 1 | 2 | 3>> {\n    logger.debug('pull path access roles request')\n    return bucketsPullPathAccessRoles(this, key, path)\n  }\n\n  /**\n   * (Experimental) Get the current default ArchiveConfig for the specified Bucket.\n   *\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @returns The default ArchiveConfig for the specified Bucket.\n   *\n   * @example\n   * Get the default ArchiveConfig\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function getDefaultConfig (buckets: Buckets, key: string) {\n   *    const defaultConfig = await buckets.defaultArchiveConfig(key)\n   * }\n   * ```\n   */\n  async defaultArchiveConfig(key: string): Promise<ArchiveConfig> {\n    logger.debug('default archive config request')\n    return bucketsDefaultArchiveConfig(this, key)\n  }\n\n  /**\n   * (Experimental) Set the default ArchiveConfig for the specified Bucket.\n   *\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param config The ArchiveConfig to set as the new default.\n   *\n   * @example\n   * Set the default ArchiveConfig\n   * ```typescript\n   * import { Buckets, ArchiveConfig } from '@textile/hub'\n   *\n   * async function setDefaultConfig (buckets: Buckets, key: string, config: ArchiveConfig) {\n   *    await buckets.setDefaultArchiveConfig(key, config)\n   * }\n   * ```\n   */\n  async setDefaultArchiveConfig(\n    key: string,\n    config: ArchiveConfig,\n  ): Promise<void> {\n    logger.debug('set default archive config request')\n    return bucketsSetDefaultArchiveConfig(this, key, config)\n  }\n\n  /**\n   * (Experimental) Store a snapshot of the bucket on Filecoin.\n   * @remarks\n   * Filecoin support is experimental. By using Textile, you\n   * are acknowledging that you understand there may be risks to\n   * storing your content on or using decentralized storage\n   * services.\n   *\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   * @param options An object to set options that control the behavor of archive.\n   * @param skipAutomaticVerifiedDeal skips logic that automatically uses available datacap to make a verified deal for the archive.\n   *\n   * @example\n   * Archive a Bucket.\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function archive (buckets: Buckets, key: string) {\n   *    await buckets.archive(key)\n   * }\n   * ```\n   */\n  async archive(key: string, options?: ArchiveOptions, skipAutomaticVerifiedDeal?: boolean): Promise<void> {\n    logger.debug('archive request')\n    return bucketsArchive(this, key, options, skipAutomaticVerifiedDeal)\n  }\n\n  /**\n   * archives returns the curent and historical archives for a Bucket.\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   *\n   * @example\n   * Get current and historical archives\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function status (buckets: Buckets, key: string) {\n   *    const { current, history } = await buckets.archives(key)\n   * }\n   * ```\n   */\n  async archives(key: string): Promise<Archives> {\n    logger.debug('archives request')\n    return bucketsArchives(this, key)\n  }\n\n  /**\n   * archiveWatch watches status events from a Filecoin bucket archive.\n   * @beta\n   * @param key Unique (IPNS compatible) identifier key for a bucket.\n   *\n   * @example\n   * Watch deal state changes for a active bucket archive request.\n   * ```typescript\n   * import { Buckets } from '@textile/hub'\n   *\n   * async function logChanges (buckets: Buckets, key: string) {\n   *    const log = (reply?: {id?: string, msg: string}, err?: Error | undefined) => {\n   *        if (err || !reply) return console.log(err)\n   *        console.log(reply.id, reply.msg)\n   *    }\n   *    buckets.archiveWatch(key, log)\n   * }\n   * ```\n   */\n  async archiveWatch(\n    key: string,\n    callback: (\n      reply?: { id: string | undefined; msg: string },\n      err?: Error,\n    ) => void,\n  ): Promise<() => void> {\n    logger.debug('archive watch request')\n    return bucketsArchiveWatch(this, key, callback)\n  }\n}\n"]}