{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,8CAA0C;AAE1C,8DAAyD;AACzD,oEAAoD;AA6CpD;;;;;GAKG;AACH,MAAa,kBAAmB,SAAQ,gCAAc;IACpD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAiCG;IAEH,MAAM,CAAC,QAAQ,CACb,IAAwB,EACxB,UAA2B,EAAE;QAE7B,OAAO,IAAI,kBAAkB,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,KAAK,CAAC,CAAA;IAC5D,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,MAAM,CAAC,YAAY,CACjB,IAA0C,EAC1C,UAA+B,EAAE;QAEjC,MAAM,OAAO,GACX,OAAO,IAAI,KAAK,QAAQ;YACtB,CAAC,CAAC,iBAAO,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC;YAC1C,CAAC,CAAC,iBAAO,CAAC,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,CAAA;QACtD,OAAO,IAAI,kBAAkB,CAAC,OAAO,EAAE,OAAO,CAAC,KAAK,CAAC,CAAA;IACvD,CAAC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACH,MAAM,CAAO,WAAW,CACtB,GAAY,EACZ,UAA8B,EAAE;;YAEhC,MAAM,OAAO,GAAG,IAAI,iBAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;YACzC,MAAM,OAAO,CAAC,WAAW,CAAC,GAAG,EAAE,OAAO,CAAC,IAAI,CAAC,CAAA;YAC5C,OAAO,IAAI,kBAAkB,CAAC,OAAO,EAAE,OAAO,CAAC,KAAK,CAAC,CAAA;QACvD,CAAC;KAAA;IAED;;;;;;;;;;;;;;;;OAgBG;IACH,UAAU,CAAC,QAAiB;QAC1B,IAAI,QAAQ,KAAK,SAAS;YAAE,OAAM;QAClC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAA;IACnC,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACG,QAAQ,CAAC,QAAkB;;YAC/B,MAAM,MAAM,GAAG,IAAI,2BAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YACvC,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAA;YAC7C,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;YAC7B,OAAO,KAAK,CAAA;QACd,CAAC;KAAA;IAED;;OAEG;IACG,QAAQ,CAAC,KAAa;;YAC1B,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;QAC/B,CAAC;KAAA;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA4BG;IACG,iBAAiB,CACrB,SAAiB,EACjB,QAAqE;;YAErE,MAAM,MAAM,GAAG,IAAI,2BAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YACvC,OAAO,MAAM,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAA;QACtD,CAAC;KAAA;CACF;AA3LD,gDA2LC","sourcesContent":["import { Context } from '@textile/context'\nimport { Identity } from '@textile/crypto'\nimport { GrpcConnection } from '@textile/grpc-connection'\nimport { Client } from '@textile/hub-threads-client'\nimport { KeyInfo, UserAuth } from '@textile/security'\n\n/**\n * Set the options for authenticating with an API key\n */\nexport interface WithKeyInfoOptions extends WithUserAuthOptions {\n  /**\n   * Optional. Get more detailed log information.\n   */\n  debug?: boolean\n  /**\n   * Optional. Future date for the session to expire. Short time periods are strongly recommended. (Default 30 minutes).\n   */\n  date?: Date\n  /**\n   * Development purposes only.\n   */\n  host?: string\n}\n\n/**\n * Set the options for authenticating with a user auth\n */\nexport interface WithUserAuthOptions extends CopyAuthOptions {\n  /**\n   * Optional. Get more detailed log information.\n   */\n  debug?: boolean\n  /**\n   * Development purposes only.\n   */\n  host?: string\n}\n\n/**\n * Set additional options when copying authentication.\n */\nexport interface CopyAuthOptions {\n  /**\n   * Optional. Get more detailed log information.\n   */\n  debug?: boolean\n}\n\n/**\n * Not for external use. Defines the authorization, authentication, and\n * API scoping methods used by gRPC API client classes such as Users and Buckets.\n *\n * @internal\n */\nexport class GrpcAuthentication extends GrpcConnection {\n  /**\n   * Copies the full scope and authentication from one API instance to this one.\n   * This will copy any existing authentication and authorization info, including:\n   *\n   *   - Information created withKeyInfo and withUserAuth.\n   *\n   *   - Any token generated from getToken or getTokenChallenge.\n   *\n   *   - If you scoped the instance to a specific thread using withThread\n   *\n   * @param auth any authenticated API class such as Users or Buckets.\n   *\n   * @example\n   * Copy an authenticated Users api instance to Buckets.\n   * ```typescript\n   * import { Buckets, Users } from '@textile/hub'\n   *\n   * const usersToBuckets = async (user: Users) => {\n   *   const buckets = Buckets.copyAuth(user)\n   *   return buckets\n   * }\n   * ```\n   *\n   * @example\n   * Copy an authenticated Buckets api instance to Users.\n   * ```typescript\n   * import { Buckets, Users } from '@textile/hub'\n   *\n   * const bucketsToUsers = async (buckets: Buckets) => {\n   *   const user = Users.copyAuth(buckets)\n   *   return user\n   * }\n   * ```\n   */\n\n  static copyAuth(\n    auth: GrpcAuthentication,\n    options: CopyAuthOptions = {},\n  ): GrpcAuthentication {\n    return new GrpcAuthentication(auth.context, options.debug)\n  }\n\n  /**\n   * Creates a new API client instance for accessing the gRPC API\n   * using User Group key authentication. This method is recommended for\n   * public apps where API secrets need to remain hidden from end users.\n   * @param auth The UserAuth object.\n   *\n   * @example\n   * ```@typescript\n   * import { Client, UserAuth } from '@textile/hub'\n   *\n   * async function example (userAuth: UserAuth) {\n   *   const client = await Client.withUserAuth(userAuth)\n   * }\n   * ```\n   */\n  static withUserAuth(\n    auth: UserAuth | (() => Promise<UserAuth>),\n    options: WithUserAuthOptions = {},\n  ): GrpcAuthentication {\n    const context =\n      typeof auth === 'object'\n        ? Context.fromUserAuth(auth, options.host)\n        : Context.fromUserAuthCallback(auth, options.host)\n    return new GrpcAuthentication(context, options.debug)\n  }\n\n  /**\n   * Creates a new API client instance for accessing the gRPC API\n   * using key & secret based authentication. This method is recommended\n   * for admin or insecure implementations where the non-signing keys or\n   * key with secret can be embedded directly in an app.\n   * @param key The KeyInfo object containing {key: string, secret: string}\n   *\n   * @example\n   * ```@typescript\n   * import { Client, KeyInfo } from '@textile/hub'\n   *\n   * async function start () {\n   *   const keyInfo: KeyInfo = {\n   *     key: '<api key>',\n   *     secret: '<api secret>'\n   *   }\n   *   const client = await Client.withKeyInfo(keyInfo)\n   * }\n   * ```\n   */\n  static async withKeyInfo(\n    key: KeyInfo,\n    options: WithKeyInfoOptions = {},\n  ): Promise<GrpcAuthentication> {\n    const context = new Context(options.host)\n    await context.withKeyInfo(key, options.date)\n    return new GrpcAuthentication(context, options.debug)\n  }\n\n  /**\n   * Scope future API calls to a specific thread.\n   * For both Buckets and Threads, many API calls require knowledge\n   * about which thread you are making requests against. Use `withThread`\n   * to declare your target thread before making those API calls.\n   * @param threadId the ID of the thread\n   *\n   * @example\n   * ```@typescript\n   * import { Client, ThreadID } from '@textile/hub'\n   *\n   * async function example (threadID: ThreadID) {\n   *   const id = threadID.toString()\n   *   const client = await Client.withThread(id)\n   * }\n   * ```\n   */\n  withThread(threadID?: string): void {\n    if (threadID === undefined) return\n    this.context.withThread(threadID)\n  }\n\n  /**\n   * Obtain a token for interacting with the remote API.\n   * When your app is creating new private-key based users to interact with\n   * the API using User Group keys, you must first create a new token for\n   * each new user. Tokens do not change after you create them.\n   * @param identity A user identity to use for interacting with APIs.\n   *\n   * @example\n   * ```@typescript\n   * import { Client, PrivateKey } from '@textile/hub'\n   *\n   * async function example (client: Client, identity: PrivateKey) {\n   *   const token = await client.getToken(identity)\n   *   return token\n   * }\n   * ```\n   */\n  async getToken(identity: Identity): Promise<string> {\n    const client = new Client(this.context)\n    const token = await client.getToken(identity)\n    this.context.withToken(token)\n    return token\n  }\n\n  /**\n   * Sets the user token for interacting with the remote API.\n   */\n  async setToken(token: string): Promise<void> {\n    this.context.withToken(token)\n  }\n\n  /**\n   * Obtain a token for interacting with the remote API.\n   * When your app is creating new private-key based users to interact with\n   * the API using User Group keys, you must first create a new token for\n   * each new user. Tokens do not change after you create them. This callback\n   * method will require you to handle challenge signing.\n   * @param identity A user identity to use for interacting with buckets.\n   * @param callback A callback function that takes a `challenge` argument and returns a signed\n   * message using the input challenge and the private key associated with `publicKey`.\n   * @note `publicKey` must be the corresponding public key of the private key used in `callback`.\n   *\n   * @example\n   * ```typescript\n   * import { Client, PrivateKey } from '@textile/hub'\n   *\n   * async function example (client: Client, identity: PrivateKey) {\n   *   const token = await client.getTokenChallenge(\n   *     identity.pubKey,\n   *     (challenge: Uint8Array) => {\n   *       return new Promise((resolve, reject) => {\n   *         // This is where you should program PrivateKey to respond to challenge\n   *         // Read more here: https://docs.textile.io/tutorials/hub/production-auth/\n   *       }\n   *     }\n   *   )\n   *   return token\n   * }\n   * ```\n   */\n  async getTokenChallenge(\n    publicKey: string,\n    callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>,\n  ): Promise<string> {\n    const client = new Client(this.context)\n    return client.getTokenChallenge(publicKey, callback)\n  }\n}\n"]}