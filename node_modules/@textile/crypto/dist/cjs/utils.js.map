{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { convertPublicKey, convertSecretKey } from 'ed2curve'\nimport multibase from 'multibase'\nimport nacl from 'tweetnacl'\nimport type { Private, Public } from './identity'\nimport { decodePrivateKey, decodePublicKey } from './proto.keys'\n\nconst nonceBytes = 24 // Length of nacl nonce\nconst privateKeyBytes = 32\nconst publicKeyBytes = 32 // Length of nacl ephemeral public key\n\n/**\n * Decrypts the given `data` using a Curve25519 variant of the private key.\n *\n * Assumes ciphertext includes ephemeral public key and nonce used in original\n * encryption (e.g., via {@link encrypt} function).\n *\n * @see {@link https://github.com/dchest/ed2curve-js} for conversion details.\n * @param ciphertext Data to decrypt.\n */\nexport async function decrypt(\n  ciphertext: Uint8Array,\n  privKey: Uint8Array,\n  type = 'ed25519',\n): Promise<Uint8Array> {\n  if (type !== 'ed25519') {\n    throw Error(`'${type}' type keys are not currently supported`)\n  }\n  const pk = convertSecretKey(privKey)\n  if (!pk) {\n    throw Error('could not convert key type')\n  }\n  const nonce = ciphertext.slice(0, nonceBytes)\n  const ephemeral = ciphertext.slice(nonceBytes, nonceBytes + publicKeyBytes)\n  const ct = ciphertext.slice(nonceBytes + publicKeyBytes)\n  const plaintext = nacl.box.open(ct, nonce, ephemeral, pk)\n  if (!plaintext) {\n    throw Error('failed to decrypt curve25519')\n  }\n  return Uint8Array.from(plaintext)\n}\n\n/**\n * Encrypts the given `data` using a Curve25519 variant of the public key.\n *\n * The encryption uses an ephemeral private key, which is prepended to the\n * ciphertext, along with a nonce of random bytes.\n *\n * @see {@link https://github.com/dchest/ed2curve-js} for conversion details.\n * @param data Data to encrypt.\n */\nexport async function encrypt(\n  data: Uint8Array,\n  pubKey: Uint8Array,\n  type = 'ed25519',\n): Promise<Uint8Array> {\n  if (type !== 'ed25519') {\n    throw Error(`'${type}' type keys are not currently supported`)\n  }\n  // generated ephemeral key pair\n  const ephemeral = nacl.box.keyPair()\n  // convert recipient's key into curve25519 (assumes ed25519 keys)\n  const pk = convertPublicKey(pubKey)\n  if (!pk) {\n    throw Error('could not convert key type')\n  }\n  // encrypt with nacl\n  const nonce = nacl.randomBytes(24)\n  const ciphertext = nacl.box(data, nonce, pk, ephemeral.secretKey)\n  const merged = new Uint8Array(\n    nonceBytes + publicKeyBytes + ciphertext.byteLength,\n  )\n  // prepend nonce\n  merged.set(new Uint8Array(nonce), 0)\n  // then ephemeral public key\n  merged.set(new Uint8Array(ephemeral.publicKey), nonceBytes)\n  // then cipher text\n  merged.set(new Uint8Array(ciphertext), nonceBytes + publicKeyBytes)\n  return Uint8Array.from(merged)\n}\n\n/**\n * Encode the given PublicKey's protobuf-encoded bytes to its base-32 encoded\n * multibase representation.\n * @param bytes The protobuf-encoded bytes of a {@link Public} key.\n */\nexport function publicKeyBytesToString(bytes: Uint8Array): string {\n  const encoded = multibase.encode('base32', bytes)\n  return new TextDecoder().decode(encoded)\n}\n\n/**\n * Encode the given privateKey's protobuf-encoded bytes to its base-32 encoded\n * multibase representation.\n * @param bytes The protobuf-encoded bytes of a {@link Private} key.\n */\nexport function privateKeyBytesToString(bytes: Uint8Array): string {\n  const encoded = multibase.encode('base32', bytes)\n  return new TextDecoder().decode(encoded)\n}\n\n/**\n * Encode the given PublicKey to its base-32 encoded multibase representation.\n * @param key The {@link Public} key to encode.\n */\nexport function publicKeyToString(key: Public): string {\n  return publicKeyBytesToString(key.bytes)\n}\n\n/**\n * Encode the given PrivateKey to its base-32 encoded multibase representation.\n * @param key The input PrivateKey.\n */\nexport function privateKeyToString(key: Private): string {\n  return privateKeyBytesToString(key.bytes)\n}\n\n/**\n * Decode the given base-32 encoded multibase string into a {@link Public} key.\n * @param str The base-32 encoded multibase string.\n */\nexport function publicKeyBytesFromString(str: string): Uint8Array {\n  const decoded = multibase.decode(str)\n  const obj = decodePublicKey(decoded)\n  const bytes = obj.Data\n  return bytes.slice(0, publicKeyBytes)\n}\n\n/**\n * Decode the given base-32 encoded multibase string into a {@link Private} key.\n * @param str The base-32 encoded multibase string.\n */\nexport function privateKeyFromString(str: string): Uint8Array {\n  const decoded = multibase.decode(str)\n  const obj = decodePrivateKey(decoded)\n  const bytes = obj.Data\n  // We might have the public key bytes appended twice, but we can ignore the\n  // extra public bytes on the end (no need to check it either)\n  return bytes.slice(0, privateKeyBytes)\n}\n\n/**\n * Utility function to extract the raw bytes from a {@link Public} key.\n * @param key The public key from which to extract raw bytes.\n */\nexport function extractPublicKeyBytes(key: Public): Uint8Array {\n  const obj = decodePublicKey(key.bytes)\n  const bytes = obj.Data\n  return bytes.slice(0, publicKeyBytes)\n}\n"]}