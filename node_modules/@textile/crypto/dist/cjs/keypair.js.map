{"version":3,"file":"keypair.js","sourceRoot":"","sources":["../../src/keypair.ts"],"names":[],"mappings":"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","sourcesContent":["import nacl from 'tweetnacl'\nimport { Private, Public } from './identity'\nimport { encodePrivateKey, encodePublicKey, KeyType } from './proto.keys'\nimport {\n  decrypt,\n  encrypt,\n  privateKeyFromString,\n  privateKeyToString,\n  publicKeyBytesFromString,\n  publicKeyToString,\n} from './utils'\n\n/**\n * Default implementation of the {@link Public} interface, with encryption\n * support.\n * In theory, RSA, ed25519, and secp256k1 key types (and more) should be\n * supported, although currently only ed25519 has full verify and encrypt\n * capabilities.\n * @privateRemarks Support additional key types by default. For now, sticking to ed25519\n * keeps our bundle smaller, but if needed, additional types can be added via\n * libp2p-crypto or tweetnacl.\n * @privateRemarks Separate out the generic PublicKey interface to include signing and\n * encryption methods, and then have this class implement that interface.\n *\n * @example\n * Create a private key, extract the public key string\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * function example() {\n *   const identity = PrivateKey.fromRandom()\n *   const publicKey = identity.public.toString()\n *   return publicKey\n * }\n * ```\n *\n * @example\n * Encrypt a message using another person's public key (string)\n * ```typescript\n * import { PublicKey } from '@textile/hub'\n *\n * async function example(publicKey: string) {\n *   const recipient = PublicKey.fromString(publicKey)\n *   const msg = new TextEncoder().encode('howdy!')\n *   const ciphertext = await recipient.encrypt(msg)\n *   return ciphertext\n * }\n * ```\n *\n * @example\n * Decrypt a message sent to the local user with their private key\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey, ciphertext: Uint8Array) {\n *   const plaintext = await identity.decrypt(ciphertext)\n *   return plaintext\n * }\n * ```\n *\n * @example\n * Encrypt the local user's own message for later reading.\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey) {\n *   const msg = new TextEncoder().encode('private message!')\n *   const ciphertext = await identity.public.encrypt(msg)\n *   return ciphertext // can only be decrypted by the local user\n * }\n * ```\n */\nexport class PublicKey implements Public {\n  constructor(public pubKey: Uint8Array, public type: string = 'ed25519') {\n    if (type !== 'ed25519') {\n      throw new Error('Invalid keys type')\n    }\n    this.type = type || 'ed25519'\n  }\n\n  /**\n   * Verifies the signature for the data and returns true if verification\n   * succeeded or false if it failed.\n   * @param data The data to use for verification.\n   * @param sig The signature to verify.\n   */\n  async verify(data: Uint8Array, signature: Uint8Array): Promise<boolean> {\n    return nacl.sign.detached.verify(data, signature, this.pubKey)\n  }\n\n  /**\n   * Return the base32-encoded multibase string of the `bytes` of this public\n   * key. Useful for encoding the key for sharing etc.\n   */\n  toString(): string {\n    return publicKeyToString(this)\n  }\n\n  /**\n   * Create a PublicKey from the result of calling `toString()`.\n   */\n  static fromString(str: string): PublicKey {\n    const bytes = publicKeyBytesFromString(str)\n    return new PublicKey(bytes, 'ed25519')\n  }\n\n  /**\n   * Return the protobuf-encoded bytes of this public key.\n   */\n  get bytes(): Uint8Array {\n    return encodePublicKey({\n      Type: KeyType.Ed25519,\n      Data: this.pubKey,\n    })\n  }\n\n  /**\n   * Encrypt the given data using this public key.\n   * @param data The input plaintext.\n   */\n  encrypt(data: Uint8Array): Promise<Uint8Array> {\n    return encrypt(data, this.pubKey, this.type)\n  }\n}\n\n/**\n * Default implementation of the {@link Private} interface, with decryption\n * support.\n * In theory, RSA, ed25519, and secp256k1 key types (and more) should be\n * supported, although currently only ed25519 has full sign and decrypt\n * capabilities.\n * @privateRemarks Support additional key types by default. For now, sticking to ed25519\n * keeps our bundle smaller, but if needed, additional types can be added via\n * libp2p-crypto or tweetnacl.\n * @privateRemarks Separate out the generic PrivateKey interface to include signing and\n * encryption methods, and then have this class implement that interface.\n *\n * @example\n * Create a private key, extract the public key string\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * function example() {\n *   const identity = PrivateKey.fromRandom()\n *   const publicKey = identity.public.toString()\n *   return publicKey\n * }\n * ```\n *\n * @example\n * Encrypt a message using another person's public key (string)\n * ```typescript\n * import { PublicKey } from '@textile/hub'\n *\n * async function example(publicKey: string) {\n *   const recipient = PublicKey.fromString(publicKey)\n *   const msg = new TextEncoder().encode('howdy!')\n *   const ciphertext = await recipient.encrypt(msg)\n *   return ciphertext\n * }\n * ```\n *\n * @example\n * Decrypt a message sent to the local user with their private key\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey, ciphertext: Uint8Array) {\n *   const plaintext = await identity.decrypt(ciphertext)\n *   return plaintext\n * }\n * ```\n *\n * @example\n * Encrypt the local user's own message for later reading.\n * ```typescript\n * import { PrivateKey } from '@textile/hub'\n *\n * async function example(identity: PrivateKey) {\n *   const msg = new TextEncoder().encode('private message!')\n *   const ciphertext = await identity.public.encrypt(msg)\n *   return ciphertext // can only be decrypted by the local user\n * }\n * ```\n */\nexport class PrivateKey implements Private {\n  /**\n   * The raw public key bytes.\n   */\n  pubKey: Uint8Array\n  /**\n   * The raw 32-byte secret seed\n   */\n  seed: Uint8Array\n  /**\n   * The raw private key bytes.\n   */\n  privKey: Uint8Array\n\n  /**\n   * Constructor\n   * @param secretKey Raw secret key (32-byte secret seed in ed25519)\n   * @param type Public-key signature system name. (currently only `ed25519` keys are supported)\n   */\n  constructor(secretKey: Uint8Array, public type: string = 'ed25519') {\n    if (type !== 'ed25519') {\n      throw new Error('Invalid keys type')\n    }\n    this.type = type || 'ed25519'\n    const secret = Uint8Array.from(secretKey)\n    if (secret.length !== 32) {\n      throw new Error('secretKey length is invalid')\n    }\n    const naclKeys = nacl.sign.keyPair.fromSeed(secret)\n    this.seed = secret\n    this.privKey = naclKeys.secretKey\n    this.pubKey = naclKeys.publicKey\n  }\n\n  /**\n   * Returns `true` if this key contains a secret key and can sign.\n   */\n  canSign(): boolean {\n    return !!this.privKey\n  }\n\n  /**\n   * Sign the message using this private key and return the signature.\n   * @param data The data (raw bytes) to sign.\n   */\n  async sign(data: Uint8Array): Promise<Uint8Array> {\n    if (!this.canSign()) {\n      throw new Error('cannot sign: no secret key available')\n    }\n    return nacl.sign.detached(data, this.privKey)\n  }\n\n  /**\n   * Get the public key associated with this identity.\n   */\n  get public(): PublicKey {\n    return new PublicKey(this.pubKey)\n  }\n\n  /**\n   * Return the protobuf-encoded bytes of this private key.\n   */\n  get bytes(): Uint8Array {\n    return encodePrivateKey({\n      Type: KeyType.Ed25519,\n      Data: this.privKey,\n    })\n  }\n\n  /**\n   * Creates a new PrivateKey from ed25519 secret key seed raw bytes.\n   *\n   * @param rawSeed Raw 32-byte ed25519 secret key seed.\n   */\n  static fromRawEd25519Seed(rawSeed: Uint8Array): PrivateKey {\n    return new this(rawSeed, 'ed25519')\n  }\n\n  /**\n   * Create a random PrivateKey.\n   */\n  static fromRandom(): PrivateKey {\n    const secret = nacl.randomBytes(32)\n    return this.fromRawEd25519Seed(secret)\n  }\n\n  /**\n   * Return the base32-encoded multibase string of the `bytes` of this private\n   * key. Useful for encoding the key for sharing etc.\n   */\n  toString(): string {\n    return privateKeyToString(this)\n  }\n\n  /**\n   * Create a PrivateKey from the result of calling `toString()`.\n   */\n  static fromString(str: string): PrivateKey {\n    return new PrivateKey(privateKeyFromString(str), 'ed25519')\n  }\n\n  /**\n   * Decrypt the given ciphertext using this private key.\n   * @param ciphertext The input ciphertext (encrypted data)\n   */\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array> {\n    return decrypt(ciphertext, this.privKey, this.type)\n  }\n}\n"]}