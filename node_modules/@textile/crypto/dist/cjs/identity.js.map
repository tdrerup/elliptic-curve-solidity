{"version":3,"file":"identity.js","sourceRoot":"","sources":["../../src/identity.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Identity represents an entity capable of signing a message.\n * This is a simple \"private key\" interface that must be capable of returning\n * the associated \"public key\" for verification. In many cases, the Identity\n * will just be a private key, but callers can use any setup that suits their\n * needs. The interface is currently modeled after `libp2p-crypto` keys.\n * It is meant to be implemented by external libraries, though in practice,\n * implementations are provided by the `@textile/crypto` library.\n *\n * If using in your own application, see the {@link PrivateKey} class.\n */\nexport interface Identity {\n  /**\n   * Sign the message using this identity and return the signature.\n   * @param data The data (raw bytes) to sign.\n   */\n  sign(data: Uint8Array): Promise<Uint8Array>\n\n  /**\n   * Get the public key associated with this identity. This can be any object\n   * that satisfies the {@link Public} interface.\n   */\n  public: Public\n}\n\n/**\n * Private is an alias for the {@link Identity} interface.\n */\nexport interface Private extends Identity {\n  /**\n   * Return the protobuf-encoded bytes of this private key.\n   */\n  bytes: Uint8Array\n}\n\n/**\n * Public is any entity associated with a given {@link Identity} that is\n * capable of verifying a signature produced by said identity. In most cases,\n * a public key will be obtained as a property of an object implementing the\n * {@link Identity} and/or {@link Private} key interface.\n */\nexport interface Public {\n  /**\n   * Verifies the signature for the data and returns true if verification\n   * succeeded or false if it failed.\n   * @param data The data to use for verification.\n   * @param sig The signature to verify.\n   */\n  verify(data: Uint8Array, sig: Uint8Array): Promise<boolean>\n\n  /**\n   * Return the protobuf-encoded bytes of this public key.\n   */\n  bytes: Uint8Array\n}\n"]}