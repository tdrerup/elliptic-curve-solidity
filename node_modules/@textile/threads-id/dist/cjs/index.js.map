{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import randomBytes from '@consento/sync-randombytes'\nimport multibase, { BaseNameOrCode } from 'multibase'\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore // Only used internally, so we can ignore types here\nimport { decode, encode } from 'varint'\n\n/**\n * Returns true if the two passed Uint8Arrays have the same content\n * @see {@link https://github.com/achingbrain/uint8arrays/blob/master/equals.js}\n */\nfunction equals(a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Variant denotes Thread variant. Currently only two variants are supported.\n * @public\n */\nexport enum Variant {\n  Raw = 0x55,\n  AccessControlled = 0x70, // Supports access control lists\n}\n\n/**\n * ThreadID represents a self-describing Thread identifier.\n *\n * It is formed by a Version, a Variant, and a random number of a given length.\n * @public\n *\n * @example\n * Create a new random ThreadID\n * ```typescript\n * import { ThreadID } from '@textile/threads'\n *\n * const id = ThreadID.fromRandom()\n *\n * console.log(id)\n * ```\n *\n * @example\n * Convert a ThreadID to/from a Base32 string\n * ```typescript\n * import { ThreadID } from '@textile/threads'\n *\n * const id = ThreadID.fromRandom()\n * const str = id.toString()\n * const restored = ThreadID.fromString(str)\n * ```\n */\nexport class ThreadID {\n  constructor(readonly buf: Uint8Array) {}\n\n  /**\n   * Versions. Currently only V1 is supported.\n   */\n  static V1 = 0x01\n\n  static Variant = Variant\n\n  /**\n   * fromRandom creates a new random ID object.\n   * @param variant The Thread variant to use. @see Variant\n   * @param size The size of the random component to use. Defaults to 32 bytes.\n   */\n  static fromRandom(\n    variant: Variant = ThreadID.Variant.Raw,\n    size = 32,\n  ): ThreadID {\n    // two 8 bytes (max) numbers plus random bytes\n    const bytes = Uint8Array.from([\n      ...encode(ThreadID.V1),\n      ...encode(variant),\n      ...randomBytes(new Uint8Array(size)),\n    ])\n    return new ThreadID(bytes)\n  }\n\n  /**\n   * fromString parses an ID-encoded string and returns an ID object.\n   * For IDV1, an ID-encoded string is primarily a multibase string:\n   *    <multibase-type-code><base-encoded-string>\n   * The base-encoded string represents a:\n   *    <version><variant><random-number>\n   * @param v The input encoded Thread ID.\n   */\n  static fromString(v: string | Uint8Array): ThreadID {\n    if (v.length < 2) {\n      throw new Error('id too short')\n    }\n    const data = multibase.decode(v)\n    return ThreadID.fromBytes(data)\n  }\n\n  /**\n   * fromBytes takes an ID data slice, parses it and returns an ID.\n   * For IDV1, the data bytes are arranged as:\n   *    <version><variant><random-number>\n   * Please use fromEncoded when parsing a regular ID string, as fromBytes does not\n   * expect multibase-encoded data. fromBytes accepts the output of ID.bytes().\n   * @param data The input Thread ID bytes.\n   */\n  static fromBytes(data: Uint8Array): ThreadID {\n    let copy = new Uint8Array(data)\n    const version = decode(copy)\n    if (version != 1) {\n      throw new Error(`expected 1 as the id version number, got: ${version}.`)\n    }\n    copy = copy.slice(decode.bytes, copy.length)\n    const variant = decode(copy)\n    if (!(variant in ThreadID.Variant)) {\n      throw new Error('invalid variant.')\n    }\n    const id = copy.slice(decode.bytes, copy.length)\n    if (id.length < 16) {\n      throw new Error('random component too small.')\n    }\n    return new ThreadID(data)\n  }\n\n  /**\n   * getEncoding returns the multibase encoding for a multibase encoded string.\n   * Returns the name of the encoding if it is encoded, and throws an error otherwise.\n   * @param v The Thread ID to check.\n   */\n  static getEncoding(v: string): string {\n    if (v.length < 2) {\n      throw new Error('Too Short')\n    }\n    const encoding = multibase.isEncoded(v)\n    // check encoding is valid\n    if (encoding === false) {\n      throw new Error('Invalid Encoding')\n    }\n    return encoding\n  }\n\n  /**\n   * isDefined returns true if an ID is defined.\n   * Calling any other methods on an undefined ID will result in undefined behavior.\n   */\n  isDefined(): boolean {\n    return this.buf.length > 0\n  }\n\n  /**\n   * toBytes returns the byte representation of an ID.\n   * The output of bytes can be parsed back into an ID with fromBytes.\n   */\n  toBytes(): Uint8Array {\n    return this.buf // These should not be mutated directly!\n  }\n\n  /**\n   * equals checks that two IDs are the same.\n   * @param o The other Thread ID.\n   */\n  equals(o: ThreadID): boolean {\n    return equals(this.buf, o.buf)\n  }\n\n  /**\n   * version returns the ID version.\n   */\n  version(): number {\n    return decode(this.buf)\n  }\n\n  /**\n   * variant returns the variant of an ID.\n   */\n  variant(): number {\n    let copy = new Uint8Array(this.buf)\n    decode(copy)\n    copy = copy.slice(decode.bytes)\n    return decode(copy)\n  }\n\n  /**\n   * toString returns the (multibase encoded) string representation of an ID.\n   * @param base Name of the base to use for encoding. Defaults to 'base32'.\n   */\n  toString(base: BaseNameOrCode = 'base32'): string {\n    const decoder = new TextDecoder()\n    switch (this.version()) {\n      case ThreadID.V1:\n        return decoder.decode(multibase.encode(base, this.buf))\n      default:\n        throw new Error('unknown ID version.')\n    }\n  }\n}\n\nexport default ThreadID\n"]}