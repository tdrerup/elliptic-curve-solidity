"use strict";
/**
 * @packageDocumentation
 * @module Common-KeyChain
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardKeyChain = exports.StandardKeyPair = void 0;
const buffer_1 = require("buffer/");
/**
 * Class for representing a private and public keypair in Avalanche.
 * All APIs that need key pairs should extend on this class.
 */
class StandardKeyPair {
    constructor() {
        /**
         * Returns a reference to the private key.
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} containing the private key
         */
        this.getPrivateKey = () => this.privk;
        /**
         * Returns a reference to the public key.
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} containing the public key
         */
        this.getPublicKey = () => this.pubk;
    }
}
exports.StandardKeyPair = StandardKeyPair;
/**
 * Class for representing a key chain in Avalanche.
 * All endpoints that need key chains should extend on this class.
 *
 * @typeparam KPClass extending [[StandardKeyPair]] which is used as the key in [[StandardKeyChain]]
 */
class StandardKeyChain {
    constructor() {
        this.keys = {};
        /**
         * Gets an array of addresses stored in the [[StandardKeyChain]].
         *
         * @returns An array of {@link https://github.com/feross/buffer|Buffer}  representations
         * of the addresses
         */
        this.getAddresses = () => Object.values(this.keys).map((kp) => kp.getAddress());
        /**
         * Gets an array of addresses stored in the [[StandardKeyChain]].
         *
         * @returns An array of string representations of the addresses
         */
        this.getAddressStrings = () => Object.values(this.keys).map((kp) => kp.getAddressString());
        /**
         * Removes the key pair from the list of they keys managed in the [[StandardKeyChain]].
         *
         * @param key A {@link https://github.com/feross/buffer|Buffer} for the address or
         * KPClass to remove
         *
         * @returns The boolean true if a key was removed.
         */
        this.removeKey = (key) => {
            let kaddr;
            if (key instanceof buffer_1.Buffer) {
                kaddr = key.toString("hex");
            }
            else {
                kaddr = key.getAddress().toString("hex");
            }
            if (kaddr in this.keys) {
                delete this.keys[kaddr];
                return true;
            }
            return false;
        };
        /**
         * Checks if there is a key associated with the provided address.
         *
         * @param address The address to check for existence in the keys database
         *
         * @returns True on success, false if not found
         */
        this.hasKey = (address) => address.toString("hex") in this.keys;
        /**
         * Returns the [[StandardKeyPair]] listed under the provided address
         *
         * @param address The {@link https://github.com/feross/buffer|Buffer} of the address to
         * retrieve from the keys database
         *
         * @returns A reference to the [[StandardKeyPair]] in the keys database
         */
        this.getKey = (address) => this.keys[address.toString("hex")];
    }
    /**
     * Adds the key pair to the list of the keys managed in the [[StandardKeyChain]].
     *
     * @param newKey A key pair of the appropriate class to be added to the [[StandardKeyChain]]
     */
    addKey(newKey) {
        this.keys[newKey.getAddress().toString("hex")] = newKey;
    }
}
exports.StandardKeyChain = StandardKeyChain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tbW9uL2tleWNoYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7OztBQUVILG9DQUFnQztBQUVoQzs7O0dBR0c7QUFDSCxNQUFzQixlQUFlO0lBQXJDO1FBb0RFOzs7O1dBSUc7UUFDSCxrQkFBYSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUE7UUFFeEM7Ozs7V0FJRztRQUNILGlCQUFZLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQTtJQWlDeEMsQ0FBQztDQUFBO0FBakdELDBDQWlHQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBc0IsZ0JBQWdCO0lBQXRDO1FBQ1ksU0FBSSxHQUFtQyxFQUFFLENBQUE7UUFrQm5EOzs7OztXQUtHO1FBQ0gsaUJBQVksR0FBRyxHQUFhLEVBQUUsQ0FDNUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQTtRQUV2RDs7OztXQUlHO1FBQ0gsc0JBQWlCLEdBQUcsR0FBYSxFQUFFLENBQ2pDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQTtRQVc3RDs7Ozs7OztXQU9HO1FBQ0gsY0FBUyxHQUFHLENBQUMsR0FBcUIsRUFBRSxFQUFFO1lBQ3BDLElBQUksS0FBYSxDQUFBO1lBQ2pCLElBQUksR0FBRyxZQUFZLGVBQU0sRUFBRTtnQkFDekIsS0FBSyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUE7YUFDNUI7aUJBQU07Z0JBQ0wsS0FBSyxHQUFHLEdBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUE7YUFDekM7WUFDRCxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUN0QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUE7Z0JBQ3ZCLE9BQU8sSUFBSSxDQUFBO2FBQ1o7WUFDRCxPQUFPLEtBQUssQ0FBQTtRQUNkLENBQUMsQ0FBQTtRQUVEOzs7Ozs7V0FNRztRQUNILFdBQU0sR0FBRyxDQUFDLE9BQWUsRUFBVyxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFBO1FBRTNFOzs7Ozs7O1dBT0c7UUFDSCxXQUFNLEdBQUcsQ0FBQyxPQUFlLEVBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBO0lBTzNFLENBQUM7SUF2REM7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxNQUFlO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQTtJQUN6RCxDQUFDO0NBZ0RGO0FBM0ZELDRDQTJGQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIENvbW1vbi1LZXlDaGFpblxuICovXG5cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXIvXCJcblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgcHJpdmF0ZSBhbmQgcHVibGljIGtleXBhaXIgaW4gQXZhbGFuY2hlLlxuICogQWxsIEFQSXMgdGhhdCBuZWVkIGtleSBwYWlycyBzaG91bGQgZXh0ZW5kIG9uIHRoaXMgY2xhc3MuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTdGFuZGFyZEtleVBhaXIge1xuICBwcm90ZWN0ZWQgcHViazogQnVmZmVyXG4gIHByb3RlY3RlZCBwcml2azogQnVmZmVyXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIG5ldyBrZXlwYWlyLlxuICAgKlxuICAgKiBAcGFyYW0gZW50cm9weSBPcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHByb2R1Y2Ugc2VjdXJlIGtleXNcbiAgICovXG4gIGdlbmVyYXRlS2V5OiAoZW50cm9weT86IEJ1ZmZlcikgPT4gdm9pZFxuXG4gIC8qKlxuICAgKiBJbXBvcnRzIGEgcHJpdmF0ZSBrZXkgYW5kIGdlbmVyYXRlcyB0aGUgYXBwcm9wcmlhdGUgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHByaXZrIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50aW5nIHRoZSBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmVcbiAgICovXG4gIGltcG9ydEtleTogKHByaXZrOiBCdWZmZXIpID0+IGJvb2xlYW5cblxuICAvKipcbiAgICogVGFrZXMgYSBtZXNzYWdlLCBzaWducyBpdCwgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIG1zZyBUaGUgbWVzc2FnZSB0byBzaWduXG4gICAqXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyB0aGUgc2lnbmF0dXJlXG4gICAqL1xuICBzaWduOiAobXNnOiBCdWZmZXIpID0+IEJ1ZmZlclxuXG4gIC8qKlxuICAgKiBSZWNvdmVycyB0aGUgcHVibGljIGtleSBvZiBhIG1lc3NhZ2Ugc2lnbmVyIGZyb20gYSBtZXNzYWdlIGFuZCBpdHMgYXNzb2NpYXRlZCBzaWduYXR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgdGhhdCdzIHNpZ25lZFxuICAgKiBAcGFyYW0gc2lnIFRoZSBzaWduYXR1cmUgdGhhdCdzIHNpZ25lZCBvbiB0aGUgbWVzc2FnZVxuICAgKlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgdGhlIHB1YmxpY1xuICAgKiBrZXkgb2YgdGhlIHNpZ25lclxuICAgKi9cbiAgcmVjb3ZlcjogKG1zZzogQnVmZmVyLCBzaWc6IEJ1ZmZlcikgPT4gQnVmZmVyXG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoYXQgdGhlIHByaXZhdGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgcHVibGljIGtleSBwcm9kdWNlcyB0aGVcbiAgICogc2lnbmF0dXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIG1zZyBUaGUgbWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0gc2lnIFRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBtZXNzYWdlXG4gICAqIEBwYXJhbSBwdWJrIFRoZSBwdWJsaWMga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVzc2FnZSBzaWduYXR1cmVcbiAgICpcbiAgICogQHJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlXG4gICAqL1xuICB2ZXJpZnk6IChtc2c6IEJ1ZmZlciwgc2lnOiBCdWZmZXIsIHB1Yms6IEJ1ZmZlcikgPT4gYm9vbGVhblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIHRoZSBwcml2YXRlIGtleVxuICAgKi9cbiAgZ2V0UHJpdmF0ZUtleSA9ICgpOiBCdWZmZXIgPT4gdGhpcy5wcml2a1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldFB1YmxpY0tleSA9ICgpOiBCdWZmZXIgPT4gdGhpcy5wdWJrXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgKi9cbiAgZ2V0UHJpdmF0ZUtleVN0cmluZzogKCkgPT4gc3RyaW5nXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRQdWJsaWNLZXlTdHJpbmc6ICgpID0+IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9ICByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgKi9cbiAgZ2V0QWRkcmVzczogKCkgPT4gQnVmZmVyXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFkZHJlc3MncyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzXG4gICAqL1xuICBnZXRBZGRyZXNzU3RyaW5nOiAoKSA9PiBzdHJpbmdcblxuICBhYnN0cmFjdCBjcmVhdGUoLi4uYXJnczogYW55W10pOiB0aGlzXG5cbiAgYWJzdHJhY3QgY2xvbmUoKTogdGhpc1xufVxuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBrZXkgY2hhaW4gaW4gQXZhbGFuY2hlLlxuICogQWxsIGVuZHBvaW50cyB0aGF0IG5lZWQga2V5IGNoYWlucyBzaG91bGQgZXh0ZW5kIG9uIHRoaXMgY2xhc3MuXG4gKlxuICogQHR5cGVwYXJhbSBLUENsYXNzIGV4dGVuZGluZyBbW1N0YW5kYXJkS2V5UGFpcl1dIHdoaWNoIGlzIHVzZWQgYXMgdGhlIGtleSBpbiBbW1N0YW5kYXJkS2V5Q2hhaW5dXVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3RhbmRhcmRLZXlDaGFpbjxLUENsYXNzIGV4dGVuZHMgU3RhbmRhcmRLZXlQYWlyPiB7XG4gIHByb3RlY3RlZCBrZXlzOiB7IFthZGRyZXNzOiBzdHJpbmddOiBLUENsYXNzIH0gPSB7fVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIG5ldyBbW1N0YW5kYXJkS2V5UGFpcl1dLCByZXR1cm5zIHRoZSBhZGRyZXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBZGRyZXNzIG9mIHRoZSBuZXcgW1tTdGFuZGFyZEtleVBhaXJdXVxuICAgKi9cbiAgbWFrZUtleTogKCkgPT4gS1BDbGFzc1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHByaXZhdGUga2V5LCBtYWtlcyBhIG5ldyBbW1N0YW5kYXJkS2V5UGFpcl1dLCByZXR1cm5zIHRoZSBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gcHJpdmsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEByZXR1cm5zIEEgbmV3IFtbU3RhbmRhcmRLZXlQYWlyXV1cbiAgICovXG4gIGltcG9ydEtleTogKHByaXZrOiBCdWZmZXIpID0+IEtQQ2xhc3NcblxuICAvKipcbiAgICogR2V0cyBhbiBhcnJheSBvZiBhZGRyZXNzZXMgc3RvcmVkIGluIHRoZSBbW1N0YW5kYXJkS2V5Q2hhaW5dXS5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2Yge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gIHJlcHJlc2VudGF0aW9uc1xuICAgKiBvZiB0aGUgYWRkcmVzc2VzXG4gICAqL1xuICBnZXRBZGRyZXNzZXMgPSAoKTogQnVmZmVyW10gPT5cbiAgICBPYmplY3QudmFsdWVzKHRoaXMua2V5cykubWFwKChrcCkgPT4ga3AuZ2V0QWRkcmVzcygpKVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IG9mIGFkZHJlc3NlcyBzdG9yZWQgaW4gdGhlIFtbU3RhbmRhcmRLZXlDaGFpbl1dLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIHRoZSBhZGRyZXNzZXNcbiAgICovXG4gIGdldEFkZHJlc3NTdHJpbmdzID0gKCk6IHN0cmluZ1tdID0+XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLmtleXMpLm1hcCgoa3ApID0+IGtwLmdldEFkZHJlc3NTdHJpbmcoKSlcblxuICAvKipcbiAgICogQWRkcyB0aGUga2V5IHBhaXIgdG8gdGhlIGxpc3Qgb2YgdGhlIGtleXMgbWFuYWdlZCBpbiB0aGUgW1tTdGFuZGFyZEtleUNoYWluXV0uXG4gICAqXG4gICAqIEBwYXJhbSBuZXdLZXkgQSBrZXkgcGFpciBvZiB0aGUgYXBwcm9wcmlhdGUgY2xhc3MgdG8gYmUgYWRkZWQgdG8gdGhlIFtbU3RhbmRhcmRLZXlDaGFpbl1dXG4gICAqL1xuICBhZGRLZXkobmV3S2V5OiBLUENsYXNzKSB7XG4gICAgdGhpcy5rZXlzW25ld0tleS5nZXRBZGRyZXNzKCkudG9TdHJpbmcoXCJoZXhcIildID0gbmV3S2V5XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUga2V5IHBhaXIgZnJvbSB0aGUgbGlzdCBvZiB0aGV5IGtleXMgbWFuYWdlZCBpbiB0aGUgW1tTdGFuZGFyZEtleUNoYWluXV0uXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIGFkZHJlc3Mgb3JcbiAgICogS1BDbGFzcyB0byByZW1vdmVcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGJvb2xlYW4gdHJ1ZSBpZiBhIGtleSB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUtleSA9IChrZXk6IEtQQ2xhc3MgfCBCdWZmZXIpID0+IHtcbiAgICBsZXQga2FkZHI6IHN0cmluZ1xuICAgIGlmIChrZXkgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIGthZGRyID0ga2V5LnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGthZGRyID0ga2V5LmdldEFkZHJlc3MoKS50b1N0cmluZyhcImhleFwiKVxuICAgIH1cbiAgICBpZiAoa2FkZHIgaW4gdGhpcy5rZXlzKSB7XG4gICAgICBkZWxldGUgdGhpcy5rZXlzW2thZGRyXVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZXJlIGlzIGEga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gY2hlY2sgZm9yIGV4aXN0ZW5jZSBpbiB0aGUga2V5cyBkYXRhYmFzZVxuICAgKlxuICAgKiBAcmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgaGFzS2V5ID0gKGFkZHJlc3M6IEJ1ZmZlcik6IGJvb2xlYW4gPT4gYWRkcmVzcy50b1N0cmluZyhcImhleFwiKSBpbiB0aGlzLmtleXNcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgW1tTdGFuZGFyZEtleVBhaXJdXSBsaXN0ZWQgdW5kZXIgdGhlIHByb3ZpZGVkIGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIHRoZSBhZGRyZXNzIHRvXG4gICAqIHJldHJpZXZlIGZyb20gdGhlIGtleXMgZGF0YWJhc2VcbiAgICpcbiAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhlIFtbU3RhbmRhcmRLZXlQYWlyXV0gaW4gdGhlIGtleXMgZGF0YWJhc2VcbiAgICovXG4gIGdldEtleSA9IChhZGRyZXNzOiBCdWZmZXIpOiBLUENsYXNzID0+IHRoaXMua2V5c1thZGRyZXNzLnRvU3RyaW5nKFwiaGV4XCIpXVxuXG4gIGFic3RyYWN0IGNyZWF0ZSguLi5hcmdzOiBhbnlbXSk6IHRoaXNcblxuICBhYnN0cmFjdCBjbG9uZSgpOiB0aGlzXG5cbiAgYWJzdHJhY3QgdW5pb24oa2M6IHRoaXMpOiB0aGlzXG59XG4iXX0=