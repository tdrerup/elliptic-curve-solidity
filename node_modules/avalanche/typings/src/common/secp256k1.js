"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SECP256k1KeyChain = exports.SECP256k1KeyPair = void 0;
/**
 * @packageDocumentation
 * @module Common-SECP256k1KeyChain
 */
const buffer_1 = require("buffer/");
const elliptic = __importStar(require("elliptic"));
const create_hash_1 = __importDefault(require("create-hash"));
const bintools_1 = __importDefault(require("../utils/bintools"));
const keychain_1 = require("./keychain");
const errors_1 = require("../utils/errors");
/**
 * @ignore
 */
const EC = elliptic.ec;
/**
 * @ignore
 */
const ec = new EC("secp256k1");
/**
 * @ignore
 */
const ecparams = ec.curve;
/**
 * @ignore
 */
const BN = ecparams.n.constructor;
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * Class for representing a private and public keypair on the Platform Chain.
 */
class SECP256k1KeyPair extends keychain_1.StandardKeyPair {
    /**
     * Class for representing a private and public keypair in Avalanche PlatformVM.
     */
    constructor() {
        super();
        /**
         * @ignore
         */
        this._sigFromSigBuffer = (sig) => {
            const r = new BN(bintools.copyFrom(sig, 0, 32));
            const s = new BN(bintools.copyFrom(sig, 32, 64));
            const recoveryParam = bintools
                .copyFrom(sig, 64, 65)
                .readUIntBE(0, 1);
            const sigOpt = {
                r: r,
                s: s,
                recoveryParam: recoveryParam
            };
            return sigOpt;
        };
        /**
         * Generates a new keypair.
         */
        this.generateKey = () => {
            this.keypair = ec.genKeyPair();
            // doing hex translation to get Buffer class
            this.privk = buffer_1.Buffer.from(this.keypair.getPrivate("hex").padStart(64, "0"), "hex");
            this.pubk = buffer_1.Buffer.from(this.keypair.getPublic(true, "hex").padStart(66, "0"), "hex");
        };
        /**
         * Imports a private key and generates the appropriate public key.
         *
         * @param privk A {@link https://github.com/feross/buffer|Buffer} representing the private key
         *
         * @returns true on success, false on failure
         */
        this.importKey = (privk) => {
            this.keypair = ec.keyFromPrivate(privk.toString("hex"), "hex");
            // doing hex translation to get Buffer class
            try {
                this.privk = buffer_1.Buffer.from(this.keypair.getPrivate("hex").padStart(64, "0"), "hex");
                this.pubk = buffer_1.Buffer.from(this.keypair.getPublic(true, "hex").padStart(66, "0"), "hex");
                return true; // silly I know, but the interface requires so it returns true on success, so if Buffer fails validation...
            }
            catch (error) {
                return false;
            }
        };
        /**
         * Returns the address as a {@link https://github.com/feross/buffer|Buffer}.
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} representation of the address
         */
        this.getAddress = () => {
            return this.addressFromPublicKey(this.pubk);
        };
        /**
         * Returns an address given a public key.
         *
         * @param pubk A {@link https://github.com/feross/buffer|Buffer} representing the public key
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} for the address of the public key.
         */
        this.addressFromPublicKey = (pubk) => {
            if (pubk.length === 65) {
                /* istanbul ignore next */
                pubk = buffer_1.Buffer.from(ec.keyFromPublic(pubk).getPublic(true, "hex").padStart(66, "0"), "hex"); // make compact, stick back into buffer
            }
            if (pubk.length === 33) {
                const sha256 = buffer_1.Buffer.from(create_hash_1.default("sha256").update(pubk).digest());
                const ripesha = buffer_1.Buffer.from(create_hash_1.default("ripemd160").update(sha256).digest());
                return ripesha;
            }
            /* istanbul ignore next */
            throw new errors_1.PublicKeyError("Unable to make address.");
        };
        /**
         * Returns a string representation of the private key.
         *
         * @returns A cb58 serialized string representation of the private key
         */
        this.getPrivateKeyString = () => {
            return `PrivateKey-${bintools.cb58Encode(this.privk)}`;
        };
        /**
         * Returns the public key.
         *
         * @returns A cb58 serialized string representation of the public key
         */
        this.getPublicKeyString = () => {
            return bintools.cb58Encode(this.pubk);
        };
        /**
         * Takes a message, signs it, and returns the signature.
         *
         * @param msg The message to sign, be sure to hash first if expected
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} containing the signature
         */
        this.sign = (msg) => {
            const sigObj = this.keypair.sign(msg, undefined, {
                canonical: true
            });
            const recovery = buffer_1.Buffer.alloc(1);
            recovery.writeUInt8(sigObj.recoveryParam, 0);
            const r = buffer_1.Buffer.from(sigObj.r.toArray("be", 32)); //we have to skip native Buffer class, so this is the way
            const s = buffer_1.Buffer.from(sigObj.s.toArray("be", 32)); //we have to skip native Buffer class, so this is the way
            const result = buffer_1.Buffer.concat([r, s, recovery], 65);
            return result;
        };
        /**
         * Verifies that the private key associated with the provided public key produces the signature associated with the given message.
         *
         * @param msg The message associated with the signature
         * @param sig The signature of the signed message
         *
         * @returns True on success, false on failure
         */
        this.verify = (msg, sig) => {
            const sigObj = this._sigFromSigBuffer(sig);
            return ec.verify(msg, sigObj, this.keypair);
        };
        /**
         * Recovers the public key of a message signer from a message and its associated signature.
         *
         * @param msg The message that's signed
         * @param sig The signature that's signed on the message
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} containing the public key of the signer
         */
        this.recover = (msg, sig) => {
            const sigObj = this._sigFromSigBuffer(sig);
            const pubk = ec.recoverPubKey(msg, sigObj, sigObj.recoveryParam);
            return buffer_1.Buffer.from(pubk.encodeCompressed());
        };
    }
}
exports.SECP256k1KeyPair = SECP256k1KeyPair;
/**
 * Class for representing a key chain in Avalanche.
 *
 * @typeparam SECP256k1KeyPair Class extending [[StandardKeyPair]] which is used as the key in [[SECP256k1KeyChain]]
 */
class SECP256k1KeyChain extends keychain_1.StandardKeyChain {
    addKey(newKey) {
        super.addKey(newKey);
    }
}
exports.SECP256k1KeyChain = SECP256k1KeyChain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi9zZWNwMjU2azEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7R0FHRztBQUNILG9DQUFnQztBQUNoQyxtREFBb0M7QUFDcEMsOERBQW9DO0FBQ3BDLGlFQUF3QztBQUN4Qyx5Q0FBOEQ7QUFDOUQsNENBQWdEO0FBR2hEOztHQUVHO0FBQ0gsTUFBTSxFQUFFLEdBQXVCLFFBQVEsQ0FBQyxFQUFFLENBQUE7QUFFMUM7O0dBRUc7QUFDSCxNQUFNLEVBQUUsR0FBZ0IsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUE7QUFFM0M7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBUSxFQUFFLENBQUMsS0FBSyxDQUFBO0FBRTlCOztHQUVHO0FBQ0gsTUFBTSxFQUFFLEdBQVEsUUFBUSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUE7QUFFdEM7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBYSxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFBO0FBRWpEOztHQUVHO0FBQ0gsTUFBc0IsZ0JBQWlCLFNBQVEsMEJBQWU7SUEwSzVEOztPQUVHO0lBQ0g7UUFDRSxLQUFLLEVBQUUsQ0FBQTtRQTNLVDs7V0FFRztRQUNPLHNCQUFpQixHQUFHLENBQUMsR0FBVyxFQUFnQyxFQUFFO1lBQzFFLE1BQU0sQ0FBQyxHQUFZLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFBO1lBQ3hELE1BQU0sQ0FBQyxHQUFZLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFBO1lBQ3pELE1BQU0sYUFBYSxHQUFXLFFBQVE7aUJBQ25DLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFB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LENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1lBQzFELE9BQU8sTUFBTSxDQUFBO1FBQ2YsQ0FBQyxDQUFBO1FBRUQ7Ozs7Ozs7V0FPRztRQUNILFdBQU0sR0FBRyxDQUFDLEdBQVcsRUFBRSxHQUFXLEVBQVcsRUFBRTtZQUM3QyxNQUFNLE1BQU0sR0FBaUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFBO1lBQ3hFLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUM3QyxDQUFDLENBQUE7UUFFRDs7Ozs7OztXQU9HO1FBQ0gsWUFBTyxHQUFHLENBQUMsR0FBVyxFQUFFLEdBQVcsRUFBVSxFQUFFO1lBQzdDLE1BQU0sTUFBTSxHQUFpQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUE7WUFDeEUsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQTtZQUNoRSxPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQTtRQUM3QyxDQUFDLENBQUE7SUFPRCxDQUFDO0NBQ0Y7QUFoTEQsNENBZ0xDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQXNCLGlCQUVwQixTQUFRLDJCQUE2QjtJQVFyQyxNQUFNLENBQUMsTUFBbUI7UUFDeEIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUN0QixDQUFDO0NBVUY7QUF0QkQsOENBc0JDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQ29tbW9uLVNFQ1AyNTZrMUtleUNoYWluXG4gKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCJidWZmZXIvXCJcbmltcG9ydCAqIGFzIGVsbGlwdGljIGZyb20gXCJlbGxpcHRpY1wiXG5pbXBvcnQgY3JlYXRlSGFzaCBmcm9tIFwiY3JlYXRlLWhhc2hcIlxuaW1wb3J0IEJpblRvb2xzIGZyb20gXCIuLi91dGlscy9iaW50b29sc1wiXG5pbXBvcnQgeyBTdGFuZGFyZEtleVBhaXIsIFN0YW5kYXJkS2V5Q2hhaW4gfSBmcm9tIFwiLi9rZXljaGFpblwiXG5pbXBvcnQgeyBQdWJsaWNLZXlFcnJvciB9IGZyb20gXCIuLi91dGlscy9lcnJvcnNcIlxuaW1wb3J0IHsgQk5JbnB1dCB9IGZyb20gXCJlbGxpcHRpY1wiXG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBFQzogdHlwZW9mIGVsbGlwdGljLmVjID0gZWxsaXB0aWMuZWNcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGVjOiBlbGxpcHRpYy5lYyA9IG5ldyBFQyhcInNlY3AyNTZrMVwiKVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgZWNwYXJhbXM6IGFueSA9IGVjLmN1cnZlXG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBCTjogYW55ID0gZWNwYXJhbXMubi5jb25zdHJ1Y3RvclxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgYmludG9vbHM6IEJpblRvb2xzID0gQmluVG9vbHMuZ2V0SW5zdGFuY2UoKVxuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBwcml2YXRlIGFuZCBwdWJsaWMga2V5cGFpciBvbiB0aGUgUGxhdGZvcm0gQ2hhaW4uXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTRUNQMjU2azFLZXlQYWlyIGV4dGVuZHMgU3RhbmRhcmRLZXlQYWlyIHtcbiAgcHJvdGVjdGVkIGtleXBhaXI6IGVsbGlwdGljLmVjLktleVBhaXJcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9zaWdGcm9tU2lnQnVmZmVyID0gKHNpZzogQnVmZmVyKTogZWxsaXB0aWMuZWMuU2lnbmF0dXJlT3B0aW9ucyA9PiB7XG4gICAgY29uc3QgcjogQk5JbnB1dCA9IG5ldyBCTihiaW50b29scy5jb3B5RnJvbShzaWcsIDAsIDMyKSlcbiAgICBjb25zdCBzOiBCTklucHV0ID0gbmV3IEJOKGJpbnRvb2xzLmNvcHlGcm9tKHNpZywgMzIsIDY0KSlcbiAgICBjb25zdCByZWNvdmVyeVBhcmFtOiBudW1iZXIgPSBiaW50b29sc1xuICAgICAgLmNvcHlGcm9tKHNpZywgNjQsIDY1KVxuICAgICAgLnJlYWRVSW50QkUoMCwgMSlcbiAgICBjb25zdCBzaWdPcHQgPSB7XG4gICAgICByOiByLFxuICAgICAgczogcyxcbiAgICAgIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW1cbiAgICB9XG4gICAgcmV0dXJuIHNpZ09wdFxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIG5ldyBrZXlwYWlyLlxuICAgKi9cbiAgZ2VuZXJhdGVLZXkgPSAoKSA9PiB7XG4gICAgdGhpcy5rZXlwYWlyID0gZWMuZ2VuS2V5UGFpcigpXG5cbiAgICAvLyBkb2luZyBoZXggdHJhbnNsYXRpb24gdG8gZ2V0IEJ1ZmZlciBjbGFzc1xuICAgIHRoaXMucHJpdmsgPSBCdWZmZXIuZnJvbShcbiAgICAgIHRoaXMua2V5cGFpci5nZXRQcml2YXRlKFwiaGV4XCIpLnBhZFN0YXJ0KDY0LCBcIjBcIiksXG4gICAgICBcImhleFwiXG4gICAgKVxuICAgIHRoaXMucHViayA9IEJ1ZmZlci5mcm9tKFxuICAgICAgdGhpcy5rZXlwYWlyLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKS5wYWRTdGFydCg2NiwgXCIwXCIpLFxuICAgICAgXCJoZXhcIlxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBvcnRzIGEgcHJpdmF0ZSBrZXkgYW5kIGdlbmVyYXRlcyB0aGUgYXBwcm9wcmlhdGUgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHByaXZrIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50aW5nIHRoZSBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmVcbiAgICovXG4gIGltcG9ydEtleSA9IChwcml2azogQnVmZmVyKTogYm9vbGVhbiA9PiB7XG4gICAgdGhpcy5rZXlwYWlyID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmsudG9TdHJpbmcoXCJoZXhcIiksIFwiaGV4XCIpXG4gICAgLy8gZG9pbmcgaGV4IHRyYW5zbGF0aW9uIHRvIGdldCBCdWZmZXIgY2xhc3NcbiAgICB0cnkge1xuICAgICAgdGhpcy5wcml2ayA9IEJ1ZmZlci5mcm9tKFxuICAgICAgICB0aGlzLmtleXBhaXIuZ2V0UHJpdmF0ZShcImhleFwiKS5wYWRTdGFydCg2NCwgXCIwXCIpLFxuICAgICAgICBcImhleFwiXG4gICAgICApXG4gICAgICB0aGlzLnB1YmsgPSBCdWZmZXIuZnJvbShcbiAgICAgICAgdGhpcy5rZXlwYWlyLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKS5wYWRTdGFydCg2NiwgXCIwXCIpLFxuICAgICAgICBcImhleFwiXG4gICAgICApXG4gICAgICByZXR1cm4gdHJ1ZSAvLyBzaWxseSBJIGtub3csIGJ1dCB0aGUgaW50ZXJmYWNlIHJlcXVpcmVzIHNvIGl0IHJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBzbyBpZiBCdWZmZXIgZmFpbHMgdmFsaWRhdGlvbi4uLlxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzXG4gICAqL1xuICBnZXRBZGRyZXNzID0gKCk6IEJ1ZmZlciA9PiB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc0Zyb21QdWJsaWNLZXkodGhpcy5wdWJrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFkZHJlc3MncyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzXG4gICAqL1xuICBnZXRBZGRyZXNzU3RyaW5nOiAoKSA9PiBzdHJpbmdcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhZGRyZXNzIGdpdmVuIGEgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHB1YmsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIHB1YmxpYyBrZXlcbiAgICpcbiAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIGFkZHJlc3Mgb2YgdGhlIHB1YmxpYyBrZXkuXG4gICAqL1xuICBhZGRyZXNzRnJvbVB1YmxpY0tleSA9IChwdWJrOiBCdWZmZXIpOiBCdWZmZXIgPT4ge1xuICAgIGlmIChwdWJrLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBwdWJrID0gQnVmZmVyLmZyb20oXG4gICAgICAgIGVjLmtleUZyb21QdWJsaWMocHViaykuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpLnBhZFN0YXJ0KDY2LCBcIjBcIiksXG4gICAgICAgIFwiaGV4XCJcbiAgICAgICkgLy8gbWFrZSBjb21wYWN0LCBzdGljayBiYWNrIGludG8gYnVmZmVyXG4gICAgfVxuICAgIGlmIChwdWJrLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgIGNvbnN0IHNoYTI1NjogQnVmZmVyID0gQnVmZmVyLmZyb20oXG4gICAgICAgIGNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKHB1YmspLmRpZ2VzdCgpXG4gICAgICApXG4gICAgICBjb25zdCByaXBlc2hhOiBCdWZmZXIgPSBCdWZmZXIuZnJvbShcbiAgICAgICAgY3JlYXRlSGFzaChcInJpcGVtZDE2MFwiKS51cGRhdGUoc2hhMjU2KS5kaWdlc3QoKVxuICAgICAgKVxuICAgICAgcmV0dXJuIHJpcGVzaGFcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgUHVibGljS2V5RXJyb3IoXCJVbmFibGUgdG8gbWFrZSBhZGRyZXNzLlwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5XG4gICAqL1xuICBnZXRQcml2YXRlS2V5U3RyaW5nID0gKCk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIGBQcml2YXRlS2V5LSR7YmludG9vbHMuY2I1OEVuY29kZSh0aGlzLnByaXZrKX1gXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHVibGljIGtleS5cbiAgICpcbiAgICogQHJldHVybnMgQSBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRQdWJsaWNLZXlTdHJpbmcgPSAoKTogc3RyaW5nID0+IHtcbiAgICByZXR1cm4gYmludG9vbHMuY2I1OEVuY29kZSh0aGlzLnB1YmspXG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSBtZXNzYWdlLCBzaWducyBpdCwgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIG1zZyBUaGUgbWVzc2FnZSB0byBzaWduLCBiZSBzdXJlIHRvIGhhc2ggZmlyc3QgaWYgZXhwZWN0ZWRcbiAgICpcbiAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIHRoZSBzaWduYXR1cmVcbiAgICovXG4gIHNpZ24gPSAobXNnOiBCdWZmZXIpOiBCdWZmZXIgPT4ge1xuICAgIGNvbnN0IHNpZ09iajogZWxsaXB0aWMuZWMuU2lnbmF0dXJlID0gdGhpcy5rZXlwYWlyLnNpZ24obXNnLCB1bmRlZmluZWQsIHtcbiAgICAgIGNhbm9uaWNhbDogdHJ1ZVxuICAgIH0pXG4gICAgY29uc3QgcmVjb3Zlcnk6IEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxKVxuICAgIHJlY292ZXJ5LndyaXRlVUludDgoc2lnT2JqLnJlY292ZXJ5UGFyYW0sIDApXG4gICAgY29uc3QgcjogQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnT2JqLnIudG9BcnJheShcImJlXCIsIDMyKSkgLy93ZSBoYXZlIHRvIHNraXAgbmF0aXZlIEJ1ZmZlciBjbGFzcywgc28gdGhpcyBpcyB0aGUgd2F5XG4gICAgY29uc3QgczogQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnT2JqLnMudG9BcnJheShcImJlXCIsIDMyKSkgLy93ZSBoYXZlIHRvIHNraXAgbmF0aXZlIEJ1ZmZlciBjbGFzcywgc28gdGhpcyBpcyB0aGUgd2F5XG4gICAgY29uc3QgcmVzdWx0OiBCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtyLCBzLCByZWNvdmVyeV0sIDY1KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGF0IHRoZSBwcml2YXRlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkgcHJvZHVjZXMgdGhlIHNpZ25hdHVyZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBzaWduYXR1cmVcbiAgICogQHBhcmFtIHNpZyBUaGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgbWVzc2FnZVxuICAgKlxuICAgKiBAcmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmVcbiAgICovXG4gIHZlcmlmeSA9IChtc2c6IEJ1ZmZlciwgc2lnOiBCdWZmZXIpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBzaWdPYmo6IGVsbGlwdGljLmVjLlNpZ25hdHVyZU9wdGlvbnMgPSB0aGlzLl9zaWdGcm9tU2lnQnVmZmVyKHNpZylcbiAgICByZXR1cm4gZWMudmVyaWZ5KG1zZywgc2lnT2JqLCB0aGlzLmtleXBhaXIpXG4gIH1cblxuICAvKipcbiAgICogUmVjb3ZlcnMgdGhlIHB1YmxpYyBrZXkgb2YgYSBtZXNzYWdlIHNpZ25lciBmcm9tIGEgbWVzc2FnZSBhbmQgaXRzIGFzc29jaWF0ZWQgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRoYXQncyBzaWduZWRcbiAgICogQHBhcmFtIHNpZyBUaGUgc2lnbmF0dXJlIHRoYXQncyBzaWduZWQgb24gdGhlIG1lc3NhZ2VcbiAgICpcbiAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIHRoZSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXJcbiAgICovXG4gIHJlY292ZXIgPSAobXNnOiBCdWZmZXIsIHNpZzogQnVmZmVyKTogQnVmZmVyID0+IHtcbiAgICBjb25zdCBzaWdPYmo6IGVsbGlwdGljLmVjLlNpZ25hdHVyZU9wdGlvbnMgPSB0aGlzLl9zaWdGcm9tU2lnQnVmZmVyKHNpZylcbiAgICBjb25zdCBwdWJrID0gZWMucmVjb3ZlclB1YktleShtc2csIHNpZ09iaiwgc2lnT2JqLnJlY292ZXJ5UGFyYW0pXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHB1YmsuZW5jb2RlQ29tcHJlc3NlZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBwcml2YXRlIGFuZCBwdWJsaWMga2V5cGFpciBpbiBBdmFsYW5jaGUgUGxhdGZvcm1WTS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKClcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBrZXkgY2hhaW4gaW4gQXZhbGFuY2hlLlxuICpcbiAqIEB0eXBlcGFyYW0gU0VDUDI1NmsxS2V5UGFpciBDbGFzcyBleHRlbmRpbmcgW1tTdGFuZGFyZEtleVBhaXJdXSB3aGljaCBpcyB1c2VkIGFzIHRoZSBrZXkgaW4gW1tTRUNQMjU2azFLZXlDaGFpbl1dXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTRUNQMjU2azFLZXlDaGFpbjxcbiAgU0VDUEtQQ2xhc3MgZXh0ZW5kcyBTRUNQMjU2azFLZXlQYWlyXG4+IGV4dGVuZHMgU3RhbmRhcmRLZXlDaGFpbjxTRUNQS1BDbGFzcz4ge1xuICAvKipcbiAgICogTWFrZXMgYSBuZXcga2V5IHBhaXIsIHJldHVybnMgdGhlIGFkZHJlc3MuXG4gICAqXG4gICAqIEByZXR1cm5zIEFkZHJlc3Mgb2YgdGhlIG5ldyBrZXkgcGFpclxuICAgKi9cbiAgbWFrZUtleTogKCkgPT4gU0VDUEtQQ2xhc3NcblxuICBhZGRLZXkobmV3S2V5OiBTRUNQS1BDbGFzcyk6IHZvaWQge1xuICAgIHN1cGVyLmFkZEtleShuZXdLZXkpXG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwcml2YXRlIGtleSwgbWFrZXMgYSBuZXcga2V5IHBhaXIsIHJldHVybnMgdGhlIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBwcml2ayBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9yIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcmV0dXJucyBBZGRyZXNzIG9mIHRoZSBuZXcga2V5IHBhaXJcbiAgICovXG4gIGltcG9ydEtleTogKHByaXZrOiBCdWZmZXIgfCBzdHJpbmcpID0+IFNFQ1BLUENsYXNzXG59XG4iXX0=