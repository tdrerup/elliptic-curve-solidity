"use strict";
/**
 * @packageDocumentation
 * @module Utils-Mnemonic
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer/");
const errors_1 = require("./errors");
const bip39 = require("bip39");
const randomBytes = require("randombytes");
/**
 * BIP39 Mnemonic code for generating deterministic keys.
 *
 */
class Mnemonic {
    constructor() {
        this.wordlists = bip39.wordlists;
    }
    /**
     * Retrieves the Mnemonic singleton.
     */
    static getInstance() {
        if (!Mnemonic.instance) {
            Mnemonic.instance = new Mnemonic();
        }
        return Mnemonic.instance;
    }
    /**
     * Return wordlists
     *
     * @param language a string specifying the language
     *
     * @returns A [[Wordlist]] object or array of strings
     */
    getWordlists(language) {
        if (language !== undefined) {
            return this.wordlists[language];
        }
        else {
            return this.wordlists;
        }
    }
    /**
     * Synchronously takes mnemonic and password and returns {@link https://github.com/feross/buffer|Buffer}
     *
     * @param mnemonic the mnemonic as a string
     * @param password the password as a string
     *
     * @returns A {@link https://github.com/feross/buffer|Buffer}
     */
    mnemonicToSeedSync(mnemonic, password = "") {
        const seed = bip39.mnemonicToSeedSync(mnemonic, password);
        return buffer_1.Buffer.from(seed);
    }
    /**
     * Asynchronously takes mnemonic and password and returns Promise<{@link https://github.com/feross/buffer|Buffer}>
     *
     * @param mnemonic the mnemonic as a string
     * @param password the password as a string
     *
     * @returns A {@link https://github.com/feross/buffer|Buffer}
     */
    mnemonicToSeed(mnemonic, password = "") {
        return __awaiter(this, void 0, void 0, function* () {
            const seed = yield bip39.mnemonicToSeed(mnemonic, password);
            return buffer_1.Buffer.from(seed);
        });
    }
    /**
     * Takes mnemonic and wordlist and returns buffer
     *
     * @param mnemonic the mnemonic as a string
     * @param wordlist Optional the wordlist as an array of strings
     *
     * @returns A string
     */
    mnemonicToEntropy(mnemonic, wordlist) {
        return bip39.mnemonicToEntropy(mnemonic, wordlist);
    }
    /**
     * Takes mnemonic and wordlist and returns buffer
     *
     * @param entropy the entropy as a {@link https://github.com/feross/buffer|Buffer} or as a string
     * @param wordlist Optional, the wordlist as an array of strings
     *
     * @returns A string
     */
    entropyToMnemonic(entropy, wordlist) {
        return bip39.entropyToMnemonic(entropy, wordlist);
    }
    /**
     * Validates a mnemonic
     11*
     * @param mnemonic the mnemonic as a string
     * @param wordlist Optional the wordlist as an array of strings
     *
     * @returns A string
     */
    validateMnemonic(mnemonic, wordlist) {
        return bip39.validateMnemonic(mnemonic, wordlist);
    }
    /**
     * Sets the default word list
     *
     * @param language the language as a string
     *
     */
    setDefaultWordlist(language) {
        bip39.setDefaultWordlist(language);
    }
    /**
     * Returns the language of the default word list
     *
     * @returns A string
     */
    getDefaultWordlist() {
        return bip39.getDefaultWordlist();
    }
    /**
     * Generate a random mnemonic (uses crypto.randomBytes under the hood), defaults to 256-bits of entropy
     *
     * @param strength Optional the strength as a number
     * @param rng Optional the random number generator. Defaults to crypto.randomBytes
     * @param wordlist Optional
     *
     */
    generateMnemonic(strength, rng, wordlist) {
        strength = strength || 256;
        if (strength % 32 !== 0) {
            throw new errors_1.InvalidEntropy("Error - Invalid entropy");
        }
        rng = rng || randomBytes;
        return bip39.generateMnemonic(strength, rng, wordlist);
    }
}
exports.default = Mnemonic;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW5lbW9uaWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvbW5lbW9uaWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7Ozs7Ozs7QUFFSCxvQ0FBZ0M7QUFFaEMscUNBQXlDO0FBQ3pDLE1BQU0sS0FBSyxHQUFRLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQTtBQUNuQyxNQUFNLFdBQVcsR0FBUSxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUE7QUFFL0M7OztHQUdHO0FBQ0gsTUFBcUIsUUFBUTtJQUUzQjtRQUNVLGNBQVMsR0FBYSxLQUFLLENBQUMsU0FBUyxDQUFBO0lBRHhCLENBQUM7SUFHeEI7O09BRUc7SUFDSCxNQUFNLENBQUMsV0FBVztRQUNoQixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRTtZQUN0QixRQUFRLENBQUMsUUFBUSxHQUFHLElBQUksUUFBUSxFQUFFLENBQUE7U0FDbkM7UUFDRCxPQUFPLFFBQVEsQ0FBQyxRQUFRLENBQUE7SUFDMUIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILFlBQVksQ0FBQyxRQUFpQjtRQUM1QixJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7WUFDMUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1NBQ2hDO2FBQU07WUFDTCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUE7U0FDdEI7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILGtCQUFrQixDQUFDLFFBQWdCLEVBQUUsV0FBbUIsRUFBRTtRQUN4RCxNQUFNLElBQUksR0FBVyxLQUFLLENBQUMsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFBO1FBQ2pFLE9BQU8sZUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUMxQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNHLGNBQWMsQ0FDbEIsUUFBZ0IsRUFDaEIsV0FBbUIsRUFBRTs7WUFFckIsTUFBTSxJQUFJLEdBQVcsTUFBTSxLQUFLLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQTtZQUNuRSxPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7UUFDMUIsQ0FBQztLQUFBO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILGlCQUFpQixDQUFDLFFBQWdCLEVBQUUsUUFBbUI7UUFDckQsT0FBTyxLQUFLLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBQ3BELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsaUJBQWlCLENBQUMsT0FBd0IsRUFBRSxRQUFtQjtRQUM3RCxPQUFPLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUE7SUFDbkQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxnQkFBZ0IsQ0FBQyxRQUFnQixFQUFFLFFBQW1CO1FBQ3BELE9BQU8sS0FBSyxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQTtJQUNuRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxrQkFBa0IsQ0FBQyxRQUFnQjtRQUNqQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUE7SUFDcEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxrQkFBa0I7UUFDaEIsT0FBTyxLQUFLLENBQUMsa0JBQWtCLEVBQUUsQ0FBQTtJQUNuQyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILGdCQUFnQixDQUNkLFFBQWlCLEVBQ2pCLEdBQThCLEVBQzlCLFFBQW1CO1FBRW5CLFFBQVEsR0FBRyxRQUFRLElBQUksR0FBRyxDQUFBO1FBQzFCLElBQUksUUFBUSxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUU7WUFDdkIsTUFBTSxJQUFJLHVCQUFjLENBQUMseUJBQXlCLENBQUMsQ0FBQTtTQUNwRDtRQUNELEdBQUcsR0FBRyxHQUFHLElBQUksV0FBVyxDQUFBO1FBQ3hCLE9BQU8sS0FBSyxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUE7SUFDeEQsQ0FBQztDQUNGO0FBdElELDJCQXNJQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIFV0aWxzLU1uZW1vbmljXG4gKi9cblxuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlci9cIlxuaW1wb3J0IHsgV29yZGxpc3QgfSBmcm9tIFwiZXRoZXJzXCJcbmltcG9ydCB7IEludmFsaWRFbnRyb3B5IH0gZnJvbSBcIi4vZXJyb3JzXCJcbmNvbnN0IGJpcDM5OiBhbnkgPSByZXF1aXJlKFwiYmlwMzlcIilcbmNvbnN0IHJhbmRvbUJ5dGVzOiBhbnkgPSByZXF1aXJlKFwicmFuZG9tYnl0ZXNcIilcblxuLyoqXG4gKiBCSVAzOSBNbmVtb25pYyBjb2RlIGZvciBnZW5lcmF0aW5nIGRldGVybWluaXN0aWMga2V5cy5cbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1uZW1vbmljIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IE1uZW1vbmljXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuICBwcm90ZWN0ZWQgd29yZGxpc3RzOiBzdHJpbmdbXSA9IGJpcDM5LndvcmRsaXN0c1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIE1uZW1vbmljIHNpbmdsZXRvbi5cbiAgICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBNbmVtb25pYyB7XG4gICAgaWYgKCFNbmVtb25pYy5pbnN0YW5jZSkge1xuICAgICAgTW5lbW9uaWMuaW5zdGFuY2UgPSBuZXcgTW5lbW9uaWMoKVxuICAgIH1cbiAgICByZXR1cm4gTW5lbW9uaWMuaW5zdGFuY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd29yZGxpc3RzXG4gICAqXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBhIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBsYW5ndWFnZVxuICAgKlxuICAgKiBAcmV0dXJucyBBIFtbV29yZGxpc3RdXSBvYmplY3Qgb3IgYXJyYXkgb2Ygc3RyaW5nc1xuICAgKi9cbiAgZ2V0V29yZGxpc3RzKGxhbmd1YWdlPzogc3RyaW5nKTogc3RyaW5nW10gfCBXb3JkbGlzdCB7XG4gICAgaWYgKGxhbmd1YWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLndvcmRsaXN0c1tsYW5ndWFnZV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMud29yZGxpc3RzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzbHkgdGFrZXMgbW5lbW9uaWMgYW5kIHBhc3N3b3JkIGFuZCByZXR1cm5zIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqXG4gICAqIEBwYXJhbSBtbmVtb25pYyB0aGUgbW5lbW9uaWMgYXMgYSBzdHJpbmdcbiAgICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCBhcyBhIHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqL1xuICBtbmVtb25pY1RvU2VlZFN5bmMobW5lbW9uaWM6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyA9IFwiXCIpOiBCdWZmZXIge1xuICAgIGNvbnN0IHNlZWQ6IEJ1ZmZlciA9IGJpcDM5Lm1uZW1vbmljVG9TZWVkU3luYyhtbmVtb25pYywgcGFzc3dvcmQpXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlZWQpXG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgdGFrZXMgbW5lbW9uaWMgYW5kIHBhc3N3b3JkIGFuZCByZXR1cm5zIFByb21pc2U8e0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0+XG4gICAqXG4gICAqIEBwYXJhbSBtbmVtb25pYyB0aGUgbW5lbW9uaWMgYXMgYSBzdHJpbmdcbiAgICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCBhcyBhIHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqL1xuICBhc3luYyBtbmVtb25pY1RvU2VlZChcbiAgICBtbmVtb25pYzogc3RyaW5nLFxuICAgIHBhc3N3b3JkOiBzdHJpbmcgPSBcIlwiXG4gICk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3Qgc2VlZDogQnVmZmVyID0gYXdhaXQgYmlwMzkubW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWVkKVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIG1uZW1vbmljIGFuZCB3b3JkbGlzdCBhbmQgcmV0dXJucyBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIG1uZW1vbmljIHRoZSBtbmVtb25pYyBhcyBhIHN0cmluZ1xuICAgKiBAcGFyYW0gd29yZGxpc3QgT3B0aW9uYWwgdGhlIHdvcmRsaXN0IGFzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICpcbiAgICogQHJldHVybnMgQSBzdHJpbmdcbiAgICovXG4gIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljOiBzdHJpbmcsIHdvcmRsaXN0Pzogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIHJldHVybiBiaXAzOS5tbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpXG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgbW5lbW9uaWMgYW5kIHdvcmRsaXN0IGFuZCByZXR1cm5zIGJ1ZmZlclxuICAgKlxuICAgKiBAcGFyYW0gZW50cm9weSB0aGUgZW50cm9weSBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9yIGFzIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB3b3JkbGlzdCBPcHRpb25hbCwgdGhlIHdvcmRsaXN0IGFzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICpcbiAgICogQHJldHVybnMgQSBzdHJpbmdcbiAgICovXG4gIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHk6IEJ1ZmZlciB8IHN0cmluZywgd29yZGxpc3Q/OiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGJpcDM5LmVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhIG1uZW1vbmljXG4gICAxMSpcbiAgICogQHBhcmFtIG1uZW1vbmljIHRoZSBtbmVtb25pYyBhcyBhIHN0cmluZ1xuICAgKiBAcGFyYW0gd29yZGxpc3QgT3B0aW9uYWwgdGhlIHdvcmRsaXN0IGFzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICpcbiAgICogQHJldHVybnMgQSBzdHJpbmdcbiAgICovXG4gIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWM6IHN0cmluZywgd29yZGxpc3Q/OiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGJpcDM5LnZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgd29yZCBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSBsYW5ndWFnZSB0aGUgbGFuZ3VhZ2UgYXMgYSBzdHJpbmdcbiAgICpcbiAgICovXG4gIHNldERlZmF1bHRXb3JkbGlzdChsYW5ndWFnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgYmlwMzkuc2V0RGVmYXVsdFdvcmRsaXN0KGxhbmd1YWdlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhbmd1YWdlIG9mIHRoZSBkZWZhdWx0IHdvcmQgbGlzdFxuICAgKlxuICAgKiBAcmV0dXJucyBBIHN0cmluZ1xuICAgKi9cbiAgZ2V0RGVmYXVsdFdvcmRsaXN0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGJpcDM5LmdldERlZmF1bHRXb3JkbGlzdCgpXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSByYW5kb20gbW5lbW9uaWMgKHVzZXMgY3J5cHRvLnJhbmRvbUJ5dGVzIHVuZGVyIHRoZSBob29kKSwgZGVmYXVsdHMgdG8gMjU2LWJpdHMgb2YgZW50cm9weVxuICAgKlxuICAgKiBAcGFyYW0gc3RyZW5ndGggT3B0aW9uYWwgdGhlIHN0cmVuZ3RoIGFzIGEgbnVtYmVyXG4gICAqIEBwYXJhbSBybmcgT3B0aW9uYWwgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLiBEZWZhdWx0cyB0byBjcnlwdG8ucmFuZG9tQnl0ZXNcbiAgICogQHBhcmFtIHdvcmRsaXN0IE9wdGlvbmFsXG4gICAqXG4gICAqL1xuICBnZW5lcmF0ZU1uZW1vbmljKFxuICAgIHN0cmVuZ3RoPzogbnVtYmVyLFxuICAgIHJuZz86IChzaXplOiBudW1iZXIpID0+IEJ1ZmZlcixcbiAgICB3b3JkbGlzdD86IHN0cmluZ1tdXG4gICk6IHN0cmluZyB7XG4gICAgc3RyZW5ndGggPSBzdHJlbmd0aCB8fCAyNTZcbiAgICBpZiAoc3RyZW5ndGggJSAzMiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRFbnRyb3B5KFwiRXJyb3IgLSBJbnZhbGlkIGVudHJvcHlcIilcbiAgICB9XG4gICAgcm5nID0gcm5nIHx8IHJhbmRvbUJ5dGVzXG4gICAgcmV0dXJuIGJpcDM5LmdlbmVyYXRlTW5lbW9uaWMoc3RyZW5ndGgsIHJuZywgd29yZGxpc3QpXG4gIH1cbn1cbiJdfQ==